###################################################################
# (c) Copyright IBM Corp. 2000, 2001.
# All Rights Reserved.
###################################################################
# NLS properties for the Refactoring Core

#######################################
# org.eclipse.jdt.internal.core.refactoring

Assert.assertion_failed=assertion failed; 
Assert.null_argument=null argument;

Checks.Choose_name=Choose a name
Checks.all_excluded=All resources have been excluded from refactoring. Cannot proceed
Checks.cannot_be_parsed=\"{0}\" has syntax errors. Content of that file will not be updated.
Checks.cu_not_created=Compilation unit could not be created for this element.
Checks.cu_not_parsed=Syntax errors in this compilation unit make this refactoring impossible to be performed correctly. Fix the errors first.
Checks.cu_has_compile_errors=Affected resource ''{1}'' has compile errors, which can affect accuracy of the code modification.
Checks.no_dot=Type name must not contain a dot (.)
Checks.cu_name_used=Cannot rename a compilation unit to \" {0}.java\" - this name is already used by another file in this directory
Checks.method_native=Method {0}::{1} is native. Running the modified program will cause
Checks.methodName.constructor=New method name has constructor name
Checks.methodName.exists=Method {0} already exists in {1}
Checks.methodName.overrides=New method {0} overrides existing method in {1}
Checks.has_main=Type {0} has a main method - refactoring might cause some applications (scripts etc.) to not work
Checks.constructor_name= If you proceed, the method {0}  in ''{1}'' will have a constructor name.
Checks.validateModifiedFiles=File ''{0}'' has been modified since the beginning of this operation.

#######################################
# org.eclipse.jdt.internal.core.refactoring.base
#######################################

Change.checking_for=Checking change for: {0}
Change.internal_Error=Internal Error
Change.unexpected_exception=Unexpected exception while executing a change. See log for details.

ChangeAbortException.wrapped=Exception wrapped by {0}

Refactoring.binary={0} is binary
Refactoring.not_in_model={0} does not exist in the model
Refactoring.read_only={0} is read only
Refactoring.unknown_structure={0} - unknown structure

#######################################
# org.eclipse.jdt.internal.core.refactoring.changes
#######################################
AbstractRenameChange.Renaming=Renaming...

RenameResourceChange.rename_resource=rename resource
RenameResourceChange.name=Rename \"{0}\" to: {1}

CompositeChange.CompositeChange=CompositeChange>

DeleteFromClassPathChange.remove=Remove entry from classpath of Java project:

MovePackageChange.move=Move package {0} to {1}
MoveResourceChange.moving=moving
MoveResourceChange.move=Move resource: {0} to: {1}

RenameJavaProjectChange.assert.read_only=should not be read-only
RenameJavaProjectChange.rename=Rename Java Project {0} to: {1}
RenameJavaProjectChange.update=Updating classpaths

RenameSourceFolderChange.assert.readonly=should not be read-only
RenameSourceFolderChange.assert.archive=should not be an archive
RenameSourceFolderChange.rename=Rename Source Folder {0} to: {1}
RenameSourceFolderChange.renaming=Renaming source folder

AbstractJavaElementRenameChange.checking_change=Checking change for:

AbstractDeleteChange.deleting=deleting

CreatePackageChange.Creating_package=Creating package
CreatePackageChange.Create_package=Create package

CreateCUChange.CreatingCU.operation=Creating compilation unit
CreateCUChange.CreateCU.name=Create compilation unit and primary type

DeleteFileChange.delete_file=Delete file 

DeleteFolderChange.Delete_folder=Delete folder 

DeleteSourceManipulationChange.delete=Delete

ResourceReorgChange.assert=not expected to get here

AddToClasspathChange.assert.not_expected=not expected
AddToClasspathChange.add=Add entry to classpath of Java project: 

CopyCompilationUnitChange.copy=Copy {0} to {1}

CopyPackageChange.copy=Copy package {0} to {1}

RenamePackageChange.checking_change=Checking change for: {0}
RenamePackageChange.name=Rename package:{0} to:{1}
RenamePackageChange.assert.read_only=package must not be read-only

MoveCompilationUnitChange.default_package=(default package)
MoveCompilationUnitChange.name=Move Compilation Unit {0} to: {1}

RenameCompilationUnitChange.name=Rename compilation unit: {0} to: {1}
RenameCompilationUnitChange.assert.read_only=cu must not be read-only

AbstractTextBufferChange.undo=Undo {0}
SimpleTextChange.assert.offset_negative=Offset must not be negative.
SimpleTextChange.assert.only_from={0} can only be executed from within a {1}

#######################################
# org.eclipse.jdt.internal.core.refactoring.code
#######################################

#-- Extract Method -------------------------------------------
LocalTypeAnalyzer.local_type_from_outside=Selected block references a local type declared outside the selection.
LocalTypeAnalyzer.local_type_referenced_outside=A local type declared in the selected block is referenced outside the selection.

FlowAnalyzer.execution_flow=Selected statements contain a return statement but not all possible execution flows end in a return.

ExtractMethodAnalyzer.assignments_to_local=Ambiguous return value: selected block contains more than one assignment to local variable.
ExtractMethodAnalyzer.only_method_body=Cannot extract new method from selection. Only statements from a method body can be extracted.
ExtractMethodAnalyzer.after_do_keyword=Selection may not start right after the do keyword.
ExtractMethodAnalyzer.super_or_this=Cannot extract super or this call from constructor.
ExtractMethodAnalyzer.cannot_determine_return_type=Cannot determine expression's return type. Using void instead.
ExtractMethodAnalyzer.cannot_extract_null=Cannot extract the single keyword null.
ExtractMethodAnalyzer.cannot_extract_type_reference=Currently no support to extract a single type reference.
ExtractMethodAnalyzer.branch_mismatch=Selection contains branch statement but corresponding branch target isn't selected.
ExtractMethodAnalyzer.parent_mismatch=Not all selected statements are enclosed by the same parent statement.
ExtractMethodAnalyzer.cannot_extract_anonymous_type=Cannot extract the body of a anonymous type declaration. Select whole declaration.
ExtractMethodAnalyzer.cannot_extract_variable_declaration_fragment=Cannot extract a variable declaration fragment. Select whole declaration statement.
ExtractMethodAnalyzer.cannot_extract_for_initializer=Cannot extract initialization part of a for statement.
ExtractMethodAnalyzer.cannot_extract_for_updater=Cannot extract increment part of a for statement.
ExtractMethodAnalyzer.cannot_extract_variable_declaration=Cannot extract parts of a variable declaration. Select whole declaration.
ExtractMethodAnalyzer.ambiguous_return_value=Ambiguous return value: expression, access to local or return statement extracted.

ExtractMethodRefactoring.name=Extract Method {0} in {1}
ExtractMethodRefactoring.add_method=add new method {0}
ExtractMethodRefactoring.checking_new_name=Checking new method name
ExtractMethodRefactoring.checking_selection=Checking text selection
ExtractMethodRefactoring.no_set_of_statements=Selection does not mark a set of statements. Only statements from a method body can be extracted.
ExtractMethodRefactoring.substitute_with_call=substitute statement(s) with call to {0}
ExtractMethodRefactoring.change_name=extract method {0} from method {1}
ExtractMethodRefactoring.organize_imports=Organize Imports


#-- SEF ------------------------------------------------------
SelfEncapsulateField.AccessAnalyzer.encapsulate_read_access=Encapsulate read access
SelfEncapsulateField.AccessAnalyzer.encapsulate_write_access=Encapsulate write access
SelfEncapsulateField.AccessAnalyzer.encapsulate_prefix_access=Encapsulate prefix access
SelfEncapsulateField.AccessAnalyzer.encapsulate_postfix_access=Encapsulate postfix access
SelfEncapsulateField.AccessAnalyzer.cannot_convert_postfix_expression=Cannot convert postfix expression. It is used inside another expression.

SelfEncapsulateField.name=Self Encapsulate Field
SelfEncapsulateField.getter=get{0}
SelfEncapsulateField.setter=set{0}
SelfEncapsulateField.method_exists=A method ''{0}'' already exists in type ''{1}''.
SelfEncapsulateField.compiler_errors_field=Cannot analyze field ''{0}'' due to the following compiler error: {1}
SelfEncapsulateField.compiler_errors_update={0} contains compiler errors. This may affect field access update.
SelfEncapsulateField.type_not_resolveable=The type of the selected field cannot be resolved. May be an import statement is missing.
SelfEncapsulateField.cannot_analyze_selected_field=Cannot analyze selected field ''{0}''
SelfEncapsulateField.checking_preconditions=Checking preconditions
SelfEncapsulateField.searching_for_cunits=Searching for affected compilation units
SelfEncapsulateField.analyzing=Analyzing
SelfEncapsulateField.create_changes=Create changes
SelfEncapsulateField.change_visibility=Change visibility to private
SelfEncapsulateField.add_setter=Add Setter method
SelfEncapsulateField.add_getter=Add Getter method

#-- inline temp ------------------------------------------------------
InlineTempRefactoring.name=Inline local variable
InlineTempRefactoring.syntax_errors=This file has syntax errors - please fix them first
InlineTempRefactoring.select_temp=A local variable declaration or reference must be selected to activate this refactoring
InlineTempRefactoring.method_parameter=Cannot inline method parameters
InlineTempRefactoring.exceptions_declared=Cannot inline exceptions declared in \'catch\' clauses
InlineTempRefactoring.not_initialized=Local variable ''{0}'' is not initialized at declaration
InlineTempRefactoring.assigned_more_once=Local variable ''{0}'' is assigned to more than once
InlineTempRefactoring.preview=Creating preview
InlineTempRefactoring.inline=Inline local variable
InlineTempRefactoring.inline_edit_name=Inline local variable: 
InlineTempRefactoring.remove_edit_name=Remove local variable: 

#-- extract temp ------------------------------------------------------
ExtractTempRefactoring.name=Extract Local Variable
ExtractTempRefactoring.select_expression=An expression must be selected to activate this refactoring
ExtractTempRefactoring.syntax_error=This file has syntax errors - please fix them first
ExtractTempRefactoring.explicit_constructor=Code from explicit constructor calls cannot be extracted to a variable
ExtractTempRefactoring.expression_in_method=An expression used in a method must be selected to activate this refactoring
ExtractTempRefactoring.statements=Cannot extract expressions used as statements
ExtractTempRefactoring.currently_no=This expression cannot currenty be extracted
ExtractTempRefactoring.no_void=Cannot extract an expression of type \'void'
ExtractTempRefactoring.null_literals=Cannot extract single null literals
ExtractTempRefactoring.array_initializer=Operation not applicable to an array initializer
ExtractTempRefactoring.assignment=Cannot extract assignment that is part of another expression
ExtractTempRefactoring.single_conditional_expression=Currently no support to extract a single conditional expression
ExtractTempRefactoring.convention=By convention, all names of local variables start with lowercase letters
ExtractTempRefactoring.checking_preconditions=Checking preconditions
ExtractTempRefactoring.preview=Preparing preview
ExtractTempRefactoring.extract_temp=Extract Temp
ExtractTempRefactoring.update_imports=Update imports
ExtractTempRefactoring.declare_local_variable=Declare local variable
ExtractTempRefactoring.replace=Replace expression with a local variable reference
ExtractTempRefactoring.already_used=Name ''{0}'' is already used
ExtractTempRefactoring.begining=The beginning of the selection contains characters that do not belong to a statement
ExtractTempRefactoring.name_in_new=Cannot extract this name - try selecting the whole instance creation expression

#######################################
# org.eclipse.jdt.internal.core.refactoring.rename
#######################################
RenameCompilationUnitRefactoring.name=Rename \"{0}\" to \"{1}\"
RenameCompilationUnitRefactoring.not_parsed={0} has syntax errors. No references will be updated if you proceed
RenameCompilationUnitRefactoring.not_parsed_1={0} has syntax errors.
RenameCompilationUnitRefactoring.same_name=The same name chosen

RenameFieldRefactoring.name=Rename field {0} to: {1}
RenameFieldRefactoring.hiding=After renaming, the field {0} will be hidden in the scope of the field {1} declared in type {2}
RenameFieldRefactoring.hiding2=After renaming, the field named {0} declared in type {1} will be hidden in the scope of the field {2}
RenameFieldRefactoring.another_name=Choose another name.
RenameFieldRefactoring.checking=Checking preconditions...
RenameFieldRefactoring.creating_change=Preparing preview...
RenameFieldRefactoring.field_already_defined=Field with this name is already defined.
RenameFieldRefactoring.searching=Searching for references...
RenameFieldRefactoring.deleted=The selected field has been deleted from ''{0}''
RenameFieldRefactoring.assert.new_name=new name
RenameFieldRefactoring.shadows=Problem in ''{0}''. Another name shadows access to the renamed field
RenameFieldRefactoring.already_exists=Method ''{0}'' already exists in ''{1}''
RenameFieldRefactoring.overridden=Method ''{0}'' is overridden or overrides another method
RenameFieldRefactoring.overridden_or_overrides=Method ''{0}'' is overridden or overrides another method
RenameFieldRefactoring.Rename_Field=Rename Field
RenameFieldRefactoring.Update_getter_occurrence=Update getter occurrence
RenameFieldRefactoring.Update_setter_occurrence=Update setter occurrence
RenameFieldRefactoring.searching_for_text_matches=searching for text matches
RenameFieldRefactoring.Update_field_declaration=Update field declaration
RenameFieldRefactoring.Update_field_reference=Update field reference
RenameFieldRefactoring.should_start_lowercase=By convention, Java instance field names usually start with a lowercase letter.

RenamePackageRefactoring.analyzing=Analyzing...
RenamePackageRefactoring.another_name=Choose another name.
RenamePackageRefactoring.checking=Checking preconditions...
RenamePackageRefactoring.creating_change=Preparing preview...
RenamePackageRefactoring.package_exists=Package already exists
RenamePackageRefactoring.searching=Searching for references...
RenamePackageRefactoring.update_reference=update package reference
RenamePackageRefactoring.name=Rename package: {0} to: {1}
RenamePackageRefactoring.aleady_exists=Package {0} already exists in this project

RenameMethodASTAnalyzer.name_visible=Possible problems in \"{0}\" (line number:{1}). Name {2} is already visible.

RenameMethodInInterfaceRefactoring.already_defined=A related type declares a method with the new name (and same number of parameters)
RenameMethodInInterfaceRefactoring.analyzing_hierarchy=Analyzing hierarchy...
RenameMethodInInterfaceRefactoring.checking=Checking preconditions...
RenameMethodInInterfaceRefactoring.no_class_method=Not applicable to class methods
RenameMethodInInterfaceRefactoring.special_case=Cannot rename this method because it is a special case (see the language specification section 9.2 for details)

RenameMethodRefactoring.name=Rename method {0} to: {1} 
RenameMethodRefactoring.analyzing_hierarchy=Analyzing hierarchy...
RenameMethodRefactoring.checking_name=checking new name
RenameMethodRefactoring.creating_pattern=Creating the searching pattern...
RenameMethodRefactoring.no_binary=Related method {0} (declared in {1}) is binary. Refactoring cannot be performed.
RenameMethodRefactoring.no_constructors=Not applicable to contructors
RenameMethodRefactoring.no_native=Renaming native methods will cause an unsatisfied link error on runtime.
RenameMethodRefactoring.no_native_1=Related method {0} (declared in {1}) is native. Renaming will cause an unsatisfied link error on runtime.
RenameMethodRefactoring.no_read_only=Related method {0} (declared in {1}) is read-only. Refactoring cannot be performed.
RenameMethodRefactoring.not_in_model=Related method {0} (declared in {1}) does not exist in the model.
RenameMethodRefactoring.same_name=Same name chosen
RenameMethodRefactoring.searching=Searching for references...
RenameMethodRefactoring.special_case=This method is a special case - renaming might change program''s behavior.

RenamePrivateMethodRefactoring.analyzing_cu=Analyzing compilation unit...
RenamePrivateMethodRefactoring.analyzing_hierarchy=Analyzing hierarchy...
RenamePrivateMethodRefactoring.checking=Checking preconditions...
RenamePrivateMethodRefactoring.only_private=Only applicable to private methods
RenamePrivateMethodRefactoring.assert.nothing_found=no declarations/references to a method found
RenamePrivateMethodRefactoring.assert.references_outside_cu=references to a private method found outside of its compilation unit
RenamePrivateMethodRefactoring.hierarchy_defines={0} or a type in its hierarchy defines a method named {1}
RenamePrivateMethodRefactoring.update=Update method reference

RenameStaticMethodRefactoring.analyzing_hierachy=Analyzing hierachy...
RenameStaticMethodRefactoring.checking=Checking preconditions...
RenameStaticMethodRefactoring.no_private=must not be private
RenameStaticMethodRefactoring.only_static=must be static
RenameStaticMethodRefactoring.hierachy_declares=Hierarchy declares a method named {0} with the same number of parameters.

RenameVirtualMethodRefactoring.analyzing_hierarchy=Analyzing hierarchy...
RenameVirtualMethodRefactoring.checking=Checking preconditions...
RenameVirtualMethodRefactoring.no_private=not applicable to private methods
RenameVirtualMethodRefactoring.no_static=not applicable to static methods
RenameVirtualMethodRefactoring.only_class_methods=only applicable to class methods
RenameVirtualMethodRefactoring.requieres_renaming_native=Renaming {0} requires renaming a native method. Renaming will cause {1} on runtime.
RenameVirtualMethodRefactoring.hierarchy_declares1=Hierarchy declares a method {0} with the same number of parameters.
RenameVirtualMethodRefactoring.analyzing=Analyzing \"{0}\"...

RenameMethodRefactoring.rename=Rename Method
RenameMethodRefactoring.update_occurrence=Update method occurrence
RenameMethodRefactoring.update_declaration=Update method declaration
RenameMethodRefactoring.deleted=The selected method has been deleted from ''{0}''

RenameTypeRefactoring.checking=Checking preconditions...
RenameTypeRefactoring.choose_another_name=Please choose another name.
RenameTypeRefactoring.creating_change=Preparing preview...
RenameTypeRefactoring.rename_constructor=rename constructor
RenameTypeRefactoring.searching=Searching for references...
RenameTypeRefactoring.special_case=It is a special case
RenameTypeRefactoring.update_reference=update type reference
RenameTypeRefactoring.name=Rename type:{0} to:{1}
RenameTypeRefactoring.enclosed=Type {0} is enclosed in a type named {1}
RenameTypeRefactoring.encloses=Type {0} encloses a type named {1}
RenameTypeRefactoring.exists=Type named {0} already exists in package {1}
RenameTypeRefactoring.imported=Type named {0} is imported (single-type-import) in {1} (a compilation unit must not import and declare a type with the same name)
RenameTypeRefactoring.member_type_exists=Another member type named {0} already exists in {1}
RenameTypeRefactoring.enclosed_type_native=A type enclosed in type {0} declares a native method. Renaming will cause an unsatisfied link error on runtime.
RenameTypeRefactoring.name_conflict1=Name conflict with type {0} in {1}
RenameTypeRefactoring.name_conflict2=Name conflict with type {0} declared in \"{1}\"
RenameTypeRefactoring.searching_text=searching for text matches
RenameTypeRefactoring.update=Type declaration update
RenameTypeRefactoring.does_not_exist=Type {0} does not exist in the saved version of ''{1}''
RenameTypeRefactoring.will_not_rename=Compilation unit will not be renamed
RenameTypeRefactoring.local_type=Local Type declared inside ''{0}'' is named {1}
RenameTypeRefactoring.member_type=Member Type declared inside ''{0}'' is named {1}
RenameTypeRefactoring.another_type=Another type named {0} is referenced in ''{1}''

TypeRefactoring.assert.must_exist_1=package must exist
TypeRefactoring.assert.read-only=package must not be read-only

TextMatchFinder.javadoc=text reference update in JavaDoc
TextMatchFinder.comment=text reference update in a comment
TextMatchFinder.string=text reference update in a string literal
TextMatchFinder.searching=searching for text matches in:

RippleMethodFinder.assert.contain=! visitedTypes.contains(type)
RippleMethodFinder.assert.second=second condition
RippleMethodFinder.analizing_hierarchy=analizing hierarchy

RefactoringAnalyzeUtil.name_collision=Name collision with name 

RenameTempRefactoring.must_select_local=A local variable declaration or reference must be selected to activate this refactoring
RenameTempRefactoring.only_in_methods=Currently, only local variables declared in methods can be renamed
RenameTempRefactoring.lowercase=By convention, all names of local variables start with lowercase letters
RenameTempRefactoring.rename=Rename Local Variable
RenameTempRefactoring.changeName=Rename local variable:''{0}'' to: ''{1}''

MethodChecks.overrides=The selected method overrides method ''{0}'' declared in type ''{1}''. Reform the operation there
MethodChecks.implements=The selected method is an implementation of method ''{0}'' declared in type ''{1}''

RenameJavaProjectRefactoring.rename=Rename Java project ''{0}'' to:''{1}''
RenameJavaProjectRefactoring.already_exists=A project with that name already exists
RenameJavaProjectRefactoring.read_only=Project {0} is marked as read-only

RenamePackageRefactoring.different_case=A resource exists with a different case
RenamePackageRefactoring.searching_text=searching for text matches
RenamePackageRefactoring.adding_occurrences=adding occurrences
RenamePackageRefactoring.Packagered_only=Package ''{0}'' is read-only
RenamePackageRefactoring.resource_read_only=Resource corresponding to package ''{0}'' is read-only

RenameResourceRefactoring.Internal_Error=Internal Error
RenameResourceRefactoring.alread_exists=A file or folder with this name already exists
RenameResourceRefactoring.invalidName=This is an invalid name for a file or folder
RenameResourceRefactoring.rename=Rename resource {0} to:{1}

RenameSourceFolderRefactoring.blank=Name must not start or end with a blank
RenameSourceFolderRefactoring.invalid_name=This is an invalid name for a file or folder
RenameSourceFolderRefactoring.already_exists=An element with this name already exists
RenameSourceFolderRefactoring.alread_exists=An element with this name already exists
RenameSourceFolderRefactoring.rename=Rename Source Folder:{0} to:{1}
RenameSourceFolderRefactoring.read_only=Source folder {0} is marked as read-only

#######################################
# org.eclipse.jdt.internal.core.refactoring.reorg
#######################################
MoveRefactoring.move_elements=Move elements
MoveRefactoring.reorganize_elements=Reorganize elements
MoveRefactoring.move_source_folder=move source folder

ReorgRefactoring.assert.destination=destination not specified
ReorgRefactoring.reorganize_elements=reorganize elements
ReorgRefactoring.assert.whyhere=not expected to get here

DeleteRefactoring.delete_resources=Delete resources
DeleteRefactoring.delete_package_fragment_root=Delete package fragment root
DeleteRefactoring.delete=Delete
DeleteRefactoring.read_only=Selected element {0} (or one or its sub-elements) is marked as read-only

MoveCuUpdateCreator.update_imports=update imports
MoveCuUpdateCreator.searching=searching for references to types in 
MoveCuUpdateCreator.update_references=update references

CopyRefactoring.copy_elements=Copy elements
CopyRefactoring.cu.copyOf1=CopyOf{0}
CopyRefactoring.cu.copyOfMore=Copy_{0}_of_{1}
CopyRefactoring.resource.copyOf1=Copy of {0}
CopyRefactoring.resource.copyOfMore=Copy ({0}) of {1}
CopyRefactoring.package.copyOf1=copyof.{0}
CopyRefactoring.package.copyOfMore=copy{0}of.{1}
CopyRefactoring.copy_source_folder=copy source folder

#######################################
# org.eclipse.jdt.internal.core.refactoring.structure
#######################################
PullUpRefactoring.Pull_Up=Pull Up
PullUpRefactoring.same_declaring_type=All selected elements must be declared in the same type
PullUpRefactoring.not_allowed=Pull up not allowed
PullUpRefactoring.subtypes_of_binary_types=Pull up is not allowed on elements declared in subtypes of binary types
PullUpRefactoring.only_fields_and_methods=Pull up is allowed only on fields and methods
PullUpRefactoring.elements_do_not_exist=Pull up is not allowed on elements that do not exist
PullUpRefactoring.no_binary_elements=Pull up is not allowed on binary elements
PullUpRefactoring.no_read_only_elements=Pull up is not allowed on read-only elements
PullUpRefactoring.no_unknown_structure=Pull up is not allowed on elements with unknown structure
PullUpRefactoring.no_static_elements=Pull up is not allowed on static elements
PullUpRefactoring.no_constructors=Pull up is not allowed on constructors
PullUpRefactoring.no_abstract_methods=Pull up is not allowed on abstract methods
PullUpRefactoring.no_native_methods=Pull up is not allowed on native methods
PullUpRefactoring.no_interface_members=Pull up is not allowed on interface members
PullUpRefactoring.no_java.lang.Object=Pull up is not allowed on elements declared in java.lang.Object
PullUpRefactoring.no_binary_types=Pull up is not allowed on elements declared in binary types
PullUpRefactoring.no_read_only_types=Pull up is not allowed on elements declared in read-only types
PullUpRefactoring.not_this_type=Pull up is not allowed on elements declared in this type
PullUpRefactoring.no_subclasses_of_binary_types=Pull up is not allowed on elements declared in subclasses of binary types
PullUpRefactoring.no_subclasses_of_read_only_types=Pull up is not allowed on elements declared in subclasses of read-only types
PullUpRefactoring.final_fields=Pulling up final fields will result in compilation errors if they are not initialized on creation or in constructors
PullUpRefactoring.checking_referenced_elements=Checking referenced elements
PullUpRefactoring.update_imports=Update imports
PullUpRefactoring.does_not_exist=Element {0} does not exist in the saved version of the file
PullUpRefactoring.type_not_accessible=Type ''{0}'' referenced in one of the pulled elements is not accessible from type ''{1}''
PullUpRefactoring.field_not_accessible=Field ''{0}'' referenced in one of the pulled elements is not accessible from type ''{1}''
PullUpRefactoring.method_not_accessible=Method ''{0}'' referenced in one of the pulled elements is not accessible from type ''{1}''
PullUpRefactoring.different_method_return_type=Method ''{0}'' declared in type''{1}'' has a different return type than its pulled up counterpart, which will result in compile errors if you proceed
PullUpRefactoring.different_field_type=Field ''{0}'' declared in type ''{1}'' has a different type than its pulled up counterpart
PullUpRefactoring.static_method=Method ''{0}'' declared in type ''{1}'' is \'static\', which will result in compile errors if you proceed
PullUpRefactoring.lower_visibility=Method ''{0}'' declared in type ''{1}'' has visibility lower than \'protected\', which will result in compile errors if you proceed
PullUpRefactoring.preview=Preparing preview
PullUpRefactoring.changing_visibility_to=\ (changing its visibility to ''{0}'')
PullUpRefactoring.copy_method=copy method ''{0}'' to type ''{1}''
PullUpRefactoring.copy_field=copy field ''{0}'' to type ''{1}''
PullUpRefactoring.Delete_method=Delete method ''{0}'' declared in type ''{1}''
PullUpRefactoring.Delete_field=Delete field ''{0}'' declared in type ''{1}''

ModifyParamatersRefactoring.modify_Parameters=Modify Parameters
ModifyParamatersRefactoring.checking_preconditions=Checking preconditions
ModifyParamatersRefactoring.no_changes=No parameters were renamed or reordered
ModifyParamatersRefactoring.preparing_preview=Preparing preview
ModifyParamatersRefactoring.restructure_parameters=Restructure parameters

MemberChecksUtil.signature_exists=Method ''{0}'' (with the same signature) already exists in superclass ''{1}'', which will result in compile errors if you proceed
MemberChecksUtil.same_param_count=Method ''{0}'' (with the same number of parameters) already exists in type ''{1}''
MemberChecksUtil.field_exists=Field ''{0}'' already exists in superclass ''{1}'', which will result in compile errors if you proceed

ReorderParametersRefactoring.name=Reorder Parameters
ReorderParametersRefactoring.checking_preconditions=Checking preconditions
ReorderParametersRefactoring.too_few_parameters=too few parameters
ReorderParametersRefactoring.method_deleted=The selected method has been deleted from ''{0}''
ReorderParametersRefactoring.native=Method ''{0}'' declared in type ''{1}'' is native.  Reordering parameters will cause UnsatisfiedLinkError on runtime if you do not update your native libraries
ReorderParametersRefactoring.not_found=element not found
ReorderParametersRefactoring.changeName=Reorder parameters
ReorderParametersRefactoring.preview=Preparing preview
ReorderParametersRefactoring.editName=Reorder parameters

RenameParametersRefactoring.should_start_lowercase=By convention, method parameter names usually start with a lowercase letter.
RenameParametersRefactoring.rename_Paremeters=Rename Paremeters
RenameParametersRefactoring.rename_Parameters=Rename Parameters
RenameParametersRefactoring.preview=Preparing preview
RenameParametersRefactoring.rename_method_parameter=Rename method parameter
RenameParametersRefactoring.deleted=The selected method has been deleted from ''{0}''
RenameParametersRefactoring.checking=Checking preconditions...
RenameParametersRefactoring.duplicate_name=Duplicate parameter name: {0}
RenameParametersRefactoring.no_parameters=Only applicable to methods with parameters.
RenameParametersRefactoring.rename_parameters=Rename Method Parameters


MoveMembersRefactoring.Move_Members=Move Members
MoveMembersRefactoring.same_type=All selected elements must be declared in the same type
MoveMembersRefactoring.Checking_preconditions=Checking preconditions
MoveMembersRefactoring.interface_fields=Currently, only fields declared in an interface can be moved to another interface
MoveMembersRefactoring.interface_members=Currently, members declared in an interface can be moved only to another interface
MoveMembersRefactoring.static_declaration=Static members can be declared only in top level or static types
MoveMembersRefactoring.public=public
MoveMembersRefactoring.protected=protected
MoveMembersRefactoring.private=private
MoveMembersRefactoring.package-visible=package-visible
MoveMembersRefactoring.fields_methods=Move allowed only on fields and methods
MoveMembersRefactoring.exist=Move is not allowed on elements that do not exist
MoveMembersRefactoring.binary_elements=Move is not allowed on binary elements
MoveMembersRefactoring.read_only_elements=Move is not allowed on read-only elements
MoveMembersRefactoring.structure=Move is not allowed on elements with unknown structure
MoveMembersRefactoring.interface_methods=Move is not allowed on interface methods
MoveMembersRefactoring.static_methods=Move is allowed only on static methods
MoveMembersRefactoring.static_elements=Move is allowed only on static elements (and interface fields)
MoveMembersRefactoring.constructors=Move is not allowed on constructors
MoveMembersRefactoring.Object=Move is not allowed on members declared in java.lang.Object
MoveMembersRefactoring.binary=Pull up is not allowed on members of binary types
MoveMembersRefactoring.read_only=Pull up is not allowed on members of read-only types
MoveMembersRefactoring.move_members=Move members
MoveMembersRefactoring.analyzing=Analyzing
MoveMembersRefactoring.update_imports=Update imports
MoveMembersRefactoring.Copy=Copy 
MoveMembersRefactoring.delete=Delete 
MoveMembersRefactoring.convert=Convert reference to fully qualified
MoveMembersRefactoring.not_found=Destination type ''{0}'' not be found
MoveMembersRefactoring.same=Destination and source types are the same ({0})
MoveMembersRefactoring.not_exist=Destination type ''{0}'' does not exist
MoveMembersRefactoring.dest_binary=Destination type ''{0}'' is binary
MoveMembersRefactoring.native=Moved method ''{0}'' is native. You will need to update native libraries
MoveMembersRefactoring.moved_field=Moved field ''{0}'' is {1} and will not be visible from ''{2}''
MoveMembersRefactoring.accessed_field=Accessed field ''{0}'' is {1} and will not be visible from ''{2}''
MoveMembersRefactoring.moved_method=Moved method ''{0}'' is {1} and will not be visible from ''{2}''
MoveMembersRefactoring.accessed_method=Accessed method ''{0}'' is {1} and will not be visible from ''{2}''
MoveMembersRefactoring.moved_type=Moved type ''{0}'' is {1} and will not be visible from ''{2}''
MoveMembersRefactoring.accessed_type=Accessed type ''{0}'' is {1} and will not be visible from ''{2}''

#######################################
# org.eclipse.jdt.internal.core.refactoring.surround
#######################################

SurroundWithTryCatchRefactoring.name=Surround with try/catch block
SurroundWithTryCatchAnalyzer.doesNotCover=Selection does not cover a set of statements
SurroundWithTryCatchAnalyzer.doesNotContain=Selection does not contain statements from a method body
SurroundWithTryCatchAnalyzer.noUncaughtExceptions=No uncaught exceptions are thrown by the selected code
SurroundWithTryCatchAnalyzer.onlyStatements=Can only surround statements with a try/catch block
SurroundWithTryCatchAnalyzer.cannotHandleSuper=Cannot surround a super constructor call

#######################################
# org.eclipse.jdt.internal.core.refactoring.util
#######################################

CommentAnalyzer.internal_error=Internal error during precondition checking.
CommentAnalyzer.ends_inside_comment=Selection ends inside a comment.
CommentAnalyzer.starts_inside_comment=Selection starts inside a comment.

StatementAnalyzer.doesNotCover= The selection doesn't cover a set of statements or an expression. Extend selection to a valid range using the "Expand Selection With" actions from the Edit menu.
StatementAnalyzer.beginning_of_selection=The beginning of the selection contains characters that don't belong to a statement.
StatementAnalyzer.end_of_selection=The end of the selection contains characters that don't belong to a statement.
StatementAnalyzer.do_body_expression=Operation not applicable to a do statement's body and expression.
StatementAnalyzer.for_initializer_expression=Operation not applicable to a for statement's initializer and expression part.
StatementAnalyzer.for_expression_updater=Operation not applicable to a for statement's expression and updater part.
StatementAnalyzer.for_updater_body=Operation not applicable to a for statement's updater and body part.
StatementAnalyzer.catch_argument=Operation is not applicable to a catch block's argument declaration.
StatementAnalyzer.while_expression_body=Operation not applicable to a while statement's expression and body.
StatementAnalyzer.try_statement=Selection must either cover whole try statement or parts of try, catch, or finally block.
StatementAnalyzer.switch_statement=Selection must either cover whole switch statement or parts of a single case block.
StatementAnalyzer.synchronized_statement=Seleciton must either cover whole synchronized statement or parts of the synchronized block.

CodeAnalyzer.array_initializer=Operation not applicable to an array initializer.
JavaElementUtil.initializer_in=initializer in 
JavaElementUtil.initializer=initializer

#######################################
# other
#######################################
CopyResourceString.copying=copying
CopyResourceString.copy=Copy resource {0} to {1}

RenameAnalyzeUtil.shadows=Problem in ''{0}''. Another name shadows access to the renamed element
