###################################################################
# (c) Copyright IBM Corp. 2000, 2001.
# All Rights Reserved.
###################################################################
# NLS properties for the Refactoring Core

#######################################
# org.eclipse.jdt.internal.core.refactoring

AbstractRenameChange.Renaming=Renaming...

Assert.assertion_failed=assertion failed; 
Assert.null_argument=null argument;

Checks.Choose_name=Choose a name
Checks.all_excluded=All resources have been excluded from refactoring. Cannot proceed
Checks.cannot_be_parsed=\"{0}\" has syntax errors. Content of that file will not be updated.
Checks.cu_not_created=Compilation unit could not be created for this element.
Checks.cu_not_parsed=Syntax errors in this compilation unit make this refactoring impossible to be performed correctly. Fix the errors first.
Checks.no_dot=Type name must not contain a dot (.)
Checks.no_two_dots=Compilation unit name must not contain two dots (.)
Checks.not_saved=\"{0}\" should be modified but it is not saved. Content of that file will not be updated.
Checks.cu_name_used=Cannot rename a compilation unit to \" {0}.java\" - this name is already used by another file in this directory
Checks.resource_not_accessible=Affected resource:{0} is not accesible
Checks.resource_read_only=Affected resource:{0} is read-only
Checks.method_native=Method {0}::{1} is native. Running the modified program will cause
Checks.methodName.discouraged= {0} is discouraged as a method name
Checks.methodName.exists= The new method potentially conflicts with a method in the target type. Candidate is {0}
Checks.methodInHierarchy.exists= The new method potentially conflicts with a method in the type hierarchy. Candidate is {0}
Checks.has_main=Type {0} has a main method - refactoring might cause some applications (scripts etc.) to not work

CompilationUnitChange.default_package=(default package)

CompositeChange.CompositeChange=CompositeChange>

CreateCompilationUnitChange.creating_resource=creating resource: {0}
CreateCompilationUnitChange.create_cu=Create Compilation Unit {0} in {1}

CustomSearchEngine.Searching=Searching...

DeleteCompilationUnit.deleting_resource=deleting resource: {0}
DeleteCompilationUnit.delete_cu=Delete Compilation Unit {0} from {1}

RenameResourceChange.rename_resource=rename resource
RenameResourceChange.name=Rename \"{0}\" to: {1}

#######################################
# org.eclipse.jdt.internal.core.refactoring.base

Change.checking_for=Checking change for: {0}
Change.internal_Error=Internal Error
Change.unexpected_exception=Unexpected exception while executing a change. See log for details.

ChangeAbortException.wrapped=Exception wrapped by {0}

Refactoring.binary={0} is binary
Refactoring.not_in_model={0} does not exist in the model
Refactoring.read_only={0} is read only
Refactoring.unknown_structure={0} - unknown structure
Refactoring.generic_compilation_error= The compilation unit contains a sytnax error.
Refactoring.compilation_error=Compilation error at line {0}. {1}

#######################################
#org.eclipse.jdt.internal.core.refactoring.util

CommentAnalyzer.internal_error=Internal error during precondition checking.
CommentAnalyzer.ends_inside_comment=Selection ends inside a comment.
CommentAnalyzer.starts_inside_comment=Selection starts inside a comment.

StatementAnalyzer.doesNotCover= The selection doesn't cover a set of statements or an expression. Extend selection to a valid range using the "Expand Selection With" actions from the Edit menu.
StatementAnalyzer.end_of_selection=End of selection contains characters that do not belong to a statement.
StatementAnalyzer.do_body_expression=Operation not applicable to a do statement\'s body and expression.
StatementAnalyzer.for_initializer_expression=Operation not applicable to a for statement\'s initializer and expression part.
StatementAnalyzer.for_expression_updater=Operation not applicable to a for statement\'s expression and updater part.
StatementAnalyzer.for_updater_body=Operation not applicable to a for statement\'s updater and body part.
StatementAnalyzer.catch_argument=Operation is not applicable to a catch block\'s argument declaration.
StatementAnalyzer.while_expression_body=Operation not applicable to a while statement\'s expression and body.

CodeAnalyzer.array_initializer=Operation not applicable to an array initializer.

#######################################
#org.eclipse.jdt.internal.core.refactoring.code


#-- Extract Method -------------------------------------------
LocalTypeAnalyzer.local_type_from_outside=Selected block references a local type declared outside the selection.
LocalTypeAnalyzer.local_type_referenced_outside=A local type declared in the selected block is referenced outside the selection.

FlowAnalyzer.execution_flow=Selected statements contain a return statement but not all possible execution flows end in a return.

ExtractMethodAnalyzer.assignments_to_local=Ambiguous return value: selected block contains more than one assignment to local variable.
ExtractMethodAnalyzer.only_method_body=Cannot extract new method from selection. Only statements from a method body can be extracted.
ExtractMethodAnalyzer.after_do_keyword=Selection may not start right after the do keyword.
ExtractMethodAnalyzer.super_or_this=Cannot extract super or this call from constructor.
ExtractMethodAnalyzer.cannot_determine_return_type=Cannot determine expression\'s return type. Using void instead.
ExtractMethodAnalyzer.cannot_extract_null=Cannot extract the single keyword null.
ExtractMethodAnalyzer.cannot_extract_type_reference=Currently no support to extract a single type reference.
ExtractMethodAnalyzer.branch_mismatch=Selection contains branch statement but corresponding branch target isn\'t selected.
ExtractMethodAnalyzer.parent_mismatch=Not all selected statements are enclosed by the same parent statement.
ExtractMethodAnalyzer.cannot_extract_anonymous_type=Cannot extract the body of a anonymous type declaration. Select whole declaration.
ExtractMethodAnalyzer.cannot_extract_variable_declaration_fragment=Cannot extract a variable declaration fragment. Select whole declaration statement.
ExtractMethodAnalyzer.cannot_extract_for_initializer=Cannot extract initialization part of a for statement.
ExtractMethodAnalyzer.cannot_extract_for_updater=Cannot extract increment part of a for statement.
ExtractMethodAnalyzer.cannot_extract_variable_declaration=Cannot extract parts of a variable declaration. Select whole declaration.
ExtractMethodAnalyzer.ambiguous_return_value=Ambiguous return value: expression, access to local or return statement extracted.

ExtractMethodRefactoring.name=Extract Method {0} in {1}
ExtractMethodRefactoring.add_method=add new method {0}
ExtractMethodRefactoring.checking_new_name=Checking new method name
ExtractMethodRefactoring.checking_selection=Checking text selection
ExtractMethodRefactoring.no_set_of_statements=Selection does not mark a set of statements. Only statements from a method body can be extracted.
ExtractMethodRefactoring.substitute_with_call=substitute statement(s) with call to {0}
ExtractMethodRefactoring.change_name=extract method {0} from method {1}
ExtractMethodRefactoring.organize_imports=Organize Imports


#-- SEF ------------------------------------------------------
SelfEncapsulateField.AccessAnalyzer.encapsulate_read_access=Encapsulate read access
SelfEncapsulateField.AccessAnalyzer.encapsulate_write_access=Encapsulate write access
SelfEncapsulateField.AccessAnalyzer.encapsulate_prefix_access=Encapsulate prefix access
SelfEncapsulateField.AccessAnalyzer.encapsulate_postfix_access=Encapsulate postfix access
SelfEncapsulateField.AccessAnalyzer.cannot_convert_postfix_expression=Cannot convert postfix expression. It is used inside another expression.

SelfEncapsulateField.name=Self Encapsulate Field
SelfEncapsulateField.getter=get{0}
SelfEncapsulateField.setter=set{0}
SelfEncapsulateField.method_exists=A method ''{0}'' already exists in type ''{1}''.
SelfEncapsulateField.compiler_errors_field=Cannot analyze field ''{0}'' due to the following compiler error: {1}
SelfEncapsulateField.compiler_errors_update={0} contains compiler errors. This may affect field access update.
SelfEncapsulateField.type_not_resolveable=The type of the selected field cannot be resolved. May be an import statement is missing.
SelfEncapsulateField.cannot_analyze_selected_field=Cannot analyze selected field ''{0}''
SelfEncapsulateField.checking_preconditions=Checking preconditions
SelfEncapsulateField.searching_for_cunits=Searching for affected compilation units
SelfEncapsulateField.analyzing=Analyzing
SelfEncapsulateField.create_changes=Create changes
SelfEncapsulateField.change_visibility=Change visibility to private
SelfEncapsulateField.add_setter=Add Setter method
SelfEncapsulateField.add_getter=Add Getter method


#######################################
#org.eclipse.jdt.internal.core.refactoring.cus

MoveCompilationUnitChange.default_package=(default package)
MoveCompilationUnitChange.moving=moving the compilation unit
MoveCompilationUnitChange.name=Move Compilation Unit {0} to: {1}

MoveCompilationUnitRefactoring.assert.refs_in_many_files=should not find references in more than 1 file
MoveCompilationUnitRefactoring.add_import=add import declaration {0}
MoveCompilationUnitRefactoring.analyzing=Analyzing references...
MoveCompilationUnitRefactoring.checking=Checking preconditions...
MoveCompilationUnitRefactoring.choose_another=Please choose another package
MoveCompilationUnitRefactoring.computing_imports=computing imports
MoveCompilationUnitRefactoring.creating_change=creating change
MoveCompilationUnitRefactoring.out_default=Moving out of the the default package is not supported
MoveCompilationUnitRefactoring.package_visible=package-visible
MoveCompilationUnitRefactoring.protected=protected
MoveCompilationUnitRefactoring.searching=Searching for references...
MoveCompilationUnitRefactoring.to_default=Moving to the default package is not supported
MoveCompilationUnitRefactoring.update_import=update import declaration
MoveCompilationUnitRefactoring.update_reference=update type reference
MoveCompilationUnitRefactoring.name=Move \"{0}\" to: {1}
MoveCompilationUnitRefactoring.already_exists=Compilation unit \"{0}\" already exists in {1}
MoveCompilationUnitRefactoring.type_conflict=Possible name conflict between types {0} and {1} in \"{2}\"
MoveCompilationUnitRefactoring.ref_to_ouside_element=A {0} Java element declared outside of \"{1}\" is referenced in there. 
MoveCompilationUnitRefactoring.element_referenced_ouside=A {0} java element declared in \"{1}\" is referenced in \"{2}\" (refactoring may result in compile errors)
MoveCompilationUnitRefactoring.type_exists=Type {0} exists in {1} (compilation unit: \"{2}\")
MoveCompilationUnitRefactoring.type_conflict_1=Possible name conflict between type {0} (from {1}) and {2} declared in: {3}

RenameCompilationUnitChange.name=Rename compilation unit: {0} to: {1}
RenameCompilationUnitChange.assert.read_only=cu must not be read-only

RenameCompilationUnitRefactoring.name=Rename \"{0}\" to \"{1}\"
RenameCompilationUnitRefactoring.not_in_model={0} does not exist in the model
RenameCompilationUnitRefactoring.not_parsed={0} has syntax errors. No references will be updated if you proceed
RenameCompilationUnitRefactoring.not_parsed_1={0} has syntax errors.
RenameCompilationUnitRefactoring.read_only={0} is read only
RenameCompilationUnitRefactoring.same_name=The same name chosen

#######################################
#org.eclipse.jdt.internal.core.refactoring.fields

FieldRefactoring.assert.field_must_exist=field must exist

RenameFieldASTAnalyzer.error=Possible problems in \"{0}\" (line number: {1}). Name {2} is already used.

RenameFieldRefactoring.name=Rename field {0} to: {1}
RenameFieldRefactoring.hiding=After renaming, the field {0} will be hidden in the scope of the field {1} declared in type {2}
RenameFieldRefactoring.hiding2=After renaming, the field named {0} declared in type {1} will be hidden in the scope of the field {2}
RenameFieldRefactoring.analyzing=Analyzing \"{0}\"...
RenameFieldRefactoring.another_name=Choose another name.
RenameFieldRefactoring.checking=Checking preconditions...
RenameFieldRefactoring.creating_change=Preparing preview...
RenameFieldRefactoring.field_already_defined=Field with this name is already defined.
RenameFieldRefactoring.searching=Searching for references...
RenameFieldRefactoring.update_reference=update field reference
RenameFieldRefactoring.update_references_to=update references to {0}

#######################################
#org.eclipse.jdt.internal.core.refactoring.methods

MethodRefactoring.assert.must_exist=method must exist

RenameMethodASTAnalyzer.name_visible=Possible problems in \"{0}\" (line number:{1}). Name {2} is already visible.

RenameMethodInInterfaceRefactoring.already_defined=A related type declares a method with the new name (and same number of parameters)
RenameMethodInInterfaceRefactoring.analyzing_hierarchy=Analyzing hierarchy...
RenameMethodInInterfaceRefactoring.checking=Checking preconditions...
RenameMethodInInterfaceRefactoring.no_class_method=Not applicable to class methods
RenameMethodInInterfaceRefactoring.special_case=Cannot rename this method because it is a special case (see the language specification section 9.2 for details)

RenameMethodRefactoring.name=Rename method {0} to: {1} 
RenameMethodRefactoring.analyzing_hierarchy=Analyzing hierarchy...
RenameMethodRefactoring.checking_name=checking new name
RenameMethodRefactoring.creating_change=Preparing preview...
RenameMethodRefactoring.creating_pattern=Creating the searching pattern...
RenameMethodRefactoring.no_binary=Related method {0} (declared in {1}) is binary. Refactoring cannot be performed.
RenameMethodRefactoring.no_constructors=Not applicable to contructors
RenameMethodRefactoring.no_native=Renaming native methods will cause an unsatisfied link error on runtime.
RenameMethodRefactoring.no_native_1=Related method {0} (declared in {1}) is native. Renaming will cause an unsatisfied link error on runtime.
RenameMethodRefactoring.no_read_only=Related method {0} (declared in {1}) is read-only. Refactoring cannot be performed.
RenameMethodRefactoring.not_in_model=Related method {0} (declared in {1}) does not exist in the model.
RenameMethodRefactoring.same_name=Same name chosen
RenameMethodRefactoring.searching=Searching for references...
RenameMethodRefactoring.special_case=This method is a special case - renaming might change program''s behavior.
RenameMethodRefactoring.update_reference=update method reference
RenameMethodRefactoring.update_references=update method references

RenameParameterASTAnalyzer.error=Problem in line:{0}. Name {1} is already visible.
RenameParameterASTAnalyzer.error2=Problem in line:{0} Local variable named {1} already exists.

RenameParametersRefactoring.checking=Checking preconditions...
RenameParametersRefactoring.creating_change=Preparing preview...
RenameParametersRefactoring.duplicate_name=Duplicate parameter name: {0}
RenameParametersRefactoring.no_change=All parameter names are unchanged. Please enter new parameter names
RenameParametersRefactoring.no_parameters=Only applicable to methods with parameters.
RenameParametersRefactoring.not_saved=Compilation unit must be saved before performing this refactoring.
RenameParametersRefactoring.number_of_parameters=Must have the same number of parameters
RenameParametersRefactoring.rename_method_parameters=rename method parameters
RenameParametersRefactoring.rename_parameters=Rename Method Parameters
RenameParametersRefactoring.update_reference=update parameter reference
RenameParametersRefactoring.assert.name_null=parameter name is null: 
RenameParametersRefactoring.assert.names_null=names must not be null
RenameParametersRefactoring.assert.one_parameter=must have at least 1 parameter
RenameParametersRefactoring.assert.same_number=must have the same number of parameters

RenamePrivateMethodRefactoring.analyzing_cu=Analyzing compilation unit...
RenamePrivateMethodRefactoring.analyzing_hierarchy=Analyzing hierarchy...
RenamePrivateMethodRefactoring.checking=Checking preconditions...
RenamePrivateMethodRefactoring.declaration_change=Method declaration change
RenamePrivateMethodRefactoring.only_private=Only applicable to private methods
RenamePrivateMethodRefactoring.rename_method=Rename Method
RenamePrivateMethodRefactoring.assert.nothing_found=no declarations/references to a method found
RenamePrivateMethodRefactoring.assert.references_outside_cu=references to a private method found outside of its compilation unit
RenamePrivateMethodRefactoring.hierarchy_defines={0} or a type in its hierarchy defines a method named {1}

RenameStaticMethodRefactoring.analyzing_hierachy=Analyzing hierachy...
RenameStaticMethodRefactoring.checking=Checking preconditions...
RenameStaticMethodRefactoring.no_private=must not be private
RenameStaticMethodRefactoring.only_static=must be static
RenameStaticMethodRefactoring.hierachy_declares=Hierarchy declares a method named {0} with the same number of parameters.

RenameVirtualMethodRefactoring.analyzing_hierarchy=Analyzing hierarchy...
RenameVirtualMethodRefactoring.checking=Checking preconditions...
RenameVirtualMethodRefactoring.no_private=not applicable to private methods
RenameVirtualMethodRefactoring.no_static=not applicable to static methods
RenameVirtualMethodRefactoring.only_class_methods=only applicable to class methods
RenameVirtualMethodRefactoring.overrides_another=This method overrides another one - rename it in the most abstract type that declares it.
RenameVirtualMethodRefactoring.from_interface=Method {0} is declared in an interface - rename it there.
RenameVirtualMethodRefactoring.requieres_renaming_native=Renaming {0} requires renaming a native method. Renaming will cause {1} on runtime.
RenameVirtualMethodRefactoring.hierarchy_declares1=Hierarchy declares a method {0} with the same number of parameters.
RenameVirtualMethodRefactoring.analyzing=Analyzing \"{0}\"...

#######################################
#org.eclipse.jdt.internal.core.refactoring.packages

RenamePackageASTAnalyzer.error=Possible obscuring problems in \"{0}\" (line number: {1}). Name {2} is already used.

RenamePackageChange.checking_change=Checking change for: {0}
RenamePackageChange.name=Rename package:{0} to:{1}
RenamePackageChange.assert.read_only=package must not be read-only

RenamePackageRefactoring.analyzing=Analyzing...
RenamePackageRefactoring.another_name=Choose another name.
RenamePackageRefactoring.checking=Checking preconditions...
RenamePackageRefactoring.creating_change=Preparing preview...
RenamePackageRefactoring.no_default_package=Cannot rename the default package
RenamePackageRefactoring.package_exists=Package already exists
RenamePackageRefactoring.searching=Searching for references...
RenamePackageRefactoring.update_reference=update package reference
RenamePackageRefactoring.update_references_to=update references to {0}
RenamePackageRefactoring.assert.must_exist=package must exist
RenamePackageRefactoring.name=Rename package: {0} to: {1}
RenamePackageRefactoring.aleady_exists=Package {0} already exists in this project
RenamePackageRefactoring.analyzing_formatted=Analyzing \"{0}\"...


#######################################
#org.eclipse.jdt.internal.core.refactoring.text

AbstractTextBufferChange.undo=Undo {0}
SimpleTextChange.assert.offset_negative=Offset must not be negative.
SimpleTextChange.assert.only_from={0} can only be executed from within a {1}

#######################################
#org.eclipse.jdt.internal.core.refactoring.types

RenameTypeASTAnalyzer.import_conflict={0} causes a name conflict in import declarations in \"{1}\"
RenameTypeASTAnalyzer.conflict_with_declared_type={0} imports {1} and declares a top-level type named {2}
RenameTypeASTAnalyzer.native_param={0} is used as a parameter type for a native method {1} in \"{2}\" (line number:{3})
RenameTypeASTAnalyzer.refers_and_imports={0} refers to a type named {1} (line number:{2}) and imports (single-type-import) {3}
RenameTypeASTAnalyzer.name_visible=Name {0} is already visible in \"{1}\" (line number: {2})
RenameTypeASTAnalyzer.subclass={0} has a subclass named {1}
RenameTypeASTAnalyzer.superinterface_conflict=Name {0} is in conflict with superinterfaces list for type {1}

RenameTypeRefactoring.checking=Checking preconditions...
RenameTypeRefactoring.choose_another_name=Please choose another name.
RenameTypeRefactoring.creating_change=Preparing preview...
RenameTypeRefactoring.only_toplevel=Only applicable to top level types
RenameTypeRefactoring.rename_constructor=rename constructor
RenameTypeRefactoring.searching=Searching for references...
RenameTypeRefactoring.special_case=It is a special case
RenameTypeRefactoring.update_reference=update type reference
RenameTypeRefactoring.update_references_to=update references to {0}
RenameTypeRefactoring.name=Rename type:{0} to:{1}
RenameTypeRefactoring.enclosed=Type {0} is enclosed in a type named {1}
RenameTypeRefactoring.encloses=Type {0} encloses a type named {1}
RenameTypeRefactoring.exists=Type named {0} already exists in package {1}
RenameTypeRefactoring.imported=Type named {0} is imported (single-type-import) in {1} (a compilation unit must not import and declare a type with the same name)
RenameTypeRefactoring.type_exists_in_cu=Type {0} already exists in \"{1}\"
RenameTypeRefactoring.member_type_exists=Another member type named {0} already exists in {1}
RenameTypeRefactoring.local_type_name=A local type enclosed in type {0} is already named {1}
RenameTypeRefactoring.enclosed_type_name=A type enclosed in type {0} is already named {1}
RenameTypeRefactoring.local_type_native=A local type enclosed in type {0} declares a native method. Renaming will cause an unsatisfied link error on runtime.
RenameTypeRefactoring.enclosed_type_native=A type enclosed in type {0} declares a native method. Renaming will cause an unsatisfied link error on runtime.
RenameTypeRefactoring.name_conflict1=Name conflict with type {0} in {1}
RenameTypeRefactoring.analyzing=Analyzing \"{0}\"...
RenameTypeRefactoring.name_conflict2=Name conflict with type {0} declared in \"{1}\"

TypeRefactoring.assert.must_exist=type must exist
TypeRefactoring.assert.must_exist_1=package must exist
TypeRefactoring.assert.read-only=package must not be read-only
Checks.should_start_lowercase=By convention, Java package names usually start with a lowercase letter.
RenameFieldRefactoring.should_start_lowercase=By convention, Java instance field names usually start with a lowercase letter.
RenameParametersRefactoring.should_start_lowercase=By convention, method parameter names usually start with a lowercase letter.
