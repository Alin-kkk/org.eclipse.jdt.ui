###################################################################
# (c) Copyright IBM Corp. 2000, 2001.
# All Rights Reserved.
###################################################################
# NLS properties for the Refactoring Core

#######################################
# org.eclipse.jdt.internal.core.refactoring

Assert.assertion_failed=assertion failed; 
Assert.null_argument=null argument;

Checks.Choose_name=Choose a name
Checks.all_excluded=All resources have been excluded from refactoring. Cannot proceed
Checks.cannot_be_parsed=''{0}'' has syntax errors. Content of that file will not be updated.
Checks.cu_not_created=Compilation unit could not be created for this element.
Checks.cu_not_parsed=Syntax errors in this compilation unit make this refactoring impossible to be performed correctly. Fix the errors first.
Checks.cu_has_compile_errors=Affected resource ''{0}'' has compile errors, which can affect accuracy of the code modification.
Checks.no_dot=Type name must not contain a dot (.)
Checks.cu_name_used=Compilation unit ''{0}.java'' already exists
Checks.method_native=Method {0}::{1} is native. Running the modified program will cause
Checks.methodName.constructor=New method name has constructor name
Checks.methodName.exists=Method ''{0}'' already exists in type ''{1}''
Checks.methodName.overrides=New method ''{0}'' overrides existing method in type ''{1}''
Checks.methodName.returnTypeClash=New method ''{0}'' overrides a method declared in type ''{1}'' using a different return type.
Checks.has_main=Type {0} has a main method - refactoring might cause some applications (scripts etc.) to not work
Checks.constructor_name= If you proceed, the method {0}  in ''{1}'' will have a constructor name.
Checks.method_names_lowercase=By convention, all names of methods start with lowercase letters


#######################################
# org.eclipse.jdt.internal.core.refactoring.base
#######################################

Change.checking_for=Checking change for: {0}
Change.internal_Error=Internal Error
Change.is_unsaved={0} is unsaved
Change.is_read_only={0} is read only
Change.unexpected_exception=Unexpected exception while executing a change. See log for details.

ChangeAbortException.wrapped=Exception wrapped by {0}

Refactoring.binary={0} is binary
Refactoring.not_in_model={0} does not exist in the model
Refactoring.read_only={0} is read only
Refactoring.unknown_structure={0} - unknown structure

#######################################
# org.eclipse.jdt.internal.core.refactoring.changes
#######################################
AbstractRenameChange.Renaming=Renaming...

RenameResourceChange.rename_resource=rename resource
RenameResourceChange.name=Rename ''{0}'' to: ''{1}''

CompositeChange.CompositeChange=CompositeChange>

DeleteFromClassPathChange.remove=Remove entry from classpath of Java project:

MovePackageChange.move=Move package ''{0}'' to ''{1}''
MoveResourceChange.move=Move resource ''{0}'' to ''{1}''

RenameJavaProjectChange.assert.read_only=should not be read-only
RenameJavaProjectChange.rename=Rename Java Project ''{0}'' to ''{1}''
RenameJavaProjectChange.update=Updating classpaths

RenameSourceFolderChange.assert.readonly=should not be read-only
RenameSourceFolderChange.assert.archive=should not be an archive
RenameSourceFolderChange.rename=Rename Source Folder ''{0}'' to ''{1}''
RenameSourceFolderChange.renaming=Renaming source folder

AbstractJavaElementRenameChange.checking_change=Checking change for:

AbstractDeleteChange.deleting=deleting

CreatePackageChange.Creating_package=Creating package
CreatePackageChange.Create_package=Create package

CreateCUChange.CreatingCU.operation=Creating compilation unit
CreateCUChange.CreateCU.name=Create compilation unit and primary type

DeleteFileChange.delete_file=Delete file 

DeleteFolderChange.Delete_folder=Delete folder 

DeleteSourceManipulationChange.delete=Delete

ResourceReorgChange.assert=not expected to get here

AddToClasspathChange.assert.not_expected=not expected
AddToClasspathChange.add=Add entry to classpath of Java project: 

CopyCompilationUnitChange.copy=Copy ''{0}'' to ''{1}''

CopyPackageChange.copy=Copy package ''{0}'' to ''{1}''

RenamePackageChange.checking_change=Checking change for: {0}
RenamePackageChange.name=Rename package ''{0}'' to ''{1}''
RenamePackageChange.assert.read_only=package must not be read-only

MoveCompilationUnitChange.default_package=(default package)
MoveCompilationUnitChange.name=Move Compilation Unit ''{0}'' to ''{1}''

RenameCompilationUnitChange.name=Rename compilation unit ''{0}'' to ''{1}''
RenameCompilationUnitChange.assert.read_only=cu must not be read-only

#######################################
# org.eclipse.jdt.internal.core.refactoring.code
#######################################

#-- Extract Method -------------------------------------------
LocalTypeAnalyzer.local_type_from_outside=Selected block references a local type declared outside the selection.
LocalTypeAnalyzer.local_type_referenced_outside=A local type declared in the selected block is referenced outside the selection.

FlowAnalyzer.execution_flow=Selected statements contain a return statement but not all possible execution flows end in a return.

ExtractMethodAnalyzer.assignments_to_local=Ambiguous return value: selected block contains more than one assignment to local variable.
ExtractMethodAnalyzer.only_method_body=Cannot extract new method from selection. Only statements from a method body can be extracted.
ExtractMethodAnalyzer.after_do_keyword=Selection may not start right after the do keyword.
ExtractMethodAnalyzer.super_or_this=Cannot extract super or this call from constructor.
ExtractMethodAnalyzer.cannot_determine_return_type=Cannot determine expression's return type. Using void instead.
ExtractMethodAnalyzer.cannot_extract_null=Cannot extract the single keyword \'null\'.
ExtractMethodAnalyzer.branch_mismatch=Selection contains branch statement but corresponding branch target is not selected.
ExtractMethodAnalyzer.parent_mismatch=Not all selected statements are enclosed by the same parent statement.
ExtractMethodAnalyzer.cannot_extract_anonymous_type=Cannot extract the body of a anonymous type declaration. Select whole declaration.
ExtractMethodAnalyzer.cannot_extract_variable_declaration_fragment=Cannot extract a variable declaration fragment. Select whole declaration statement.
ExtractMethodAnalyzer.cannot_extract_for_initializer=Cannot extract initialization part of a for statement.
ExtractMethodAnalyzer.cannot_extract_for_updater=Cannot extract increment part of a for statement.
ExtractMethodAnalyzer.cannot_extract_variable_declaration=Cannot extract parts of a variable declaration. Select whole declaration.
ExtractMethodAnalyzer.cannot_extract_type_reference=Cannot extract a single type reference.
ExtractMethodAnalyzer.cannot_extract_name_in_declaration=Cannot extract the name part of a declaration.
ExtractMethodAnalyzer.ambiguous_return_value=Ambiguous return value: expression, access to local or return statement extracted.
ExtractMethodAnalyzer.compile_errors=Compilation errors in method ''{0}'' prevent analyzing the method''s body. Fix the errors first.

ExtractMethodRefactoring.name=Extract Method {0} in {1}
ExtractMethodRefactoring.add_method=add new method {0}
ExtractMethodRefactoring.checking_new_name=Checking new method name
ExtractMethodRefactoring.checking_selection=Checking text selection
ExtractMethodRefactoring.no_set_of_statements=Selection does not mark a set of statements. Only statements from a method body can be extracted.
ExtractMethodRefactoring.substitute_with_call=substitute statement(s) with call to {0}
ExtractMethodRefactoring.change_name=extract method {0} from method {1}
ExtractMethodRefactoring.organize_imports=Organize Imports
ExtractMethodRefactoring.error.nameInUse=''{0}'' is already used as a name in the selected code
ExtractMethodRefactoring.error.sameParameter=A parameter ''{0}'' already exists

#-- Inline Method ------------------------------------------------------
InlineMethodRefactoring.SourceAnalyzer.recursive_call=Method declaration contains recursive call.
InlineMethodRefactoring.SourceAnalyzer.declaration_has_errors=Method declaration has compile errors. Please fix errors first.
InlineMethodRefactoring.SourceAnalyzer.qualified_this_expressions=Cannot inline a method that uses qualified this expressions.
InlineMethodRefactoring.SourceAnalyzer.syntax_errors=Compilation unit containing method declaration has syntax errors. Please fix errors first.
InlineMethodRefactoring.SourceAnalyzer.abstract_methods=Cannot inline abstract methods.
InlineMethodRefactoring.SourceAnalyzer.constructors=Cannot inline constructors.

#-- SEF ------------------------------------------------------
SelfEncapsulateField.AccessAnalyzer.encapsulate_read_access=Encapsulate read access
SelfEncapsulateField.AccessAnalyzer.encapsulate_write_access=Encapsulate write access
SelfEncapsulateField.AccessAnalyzer.encapsulate_prefix_access=Encapsulate prefix access
SelfEncapsulateField.AccessAnalyzer.encapsulate_postfix_access=Encapsulate postfix access
SelfEncapsulateField.AccessAnalyzer.cannot_convert_postfix_expression=Cannot convert postfix expression. It is used inside another expression.

SelfEncapsulateField.name=Self Encapsulate Field
SelfEncapsulateField.method_exists=A method ''{0}'' already exists in type ''{1}''.
SelfEncapsulateField.compiler_errors_field=Cannot analyze field ''{0}'' due to the following compiler error: {1}
SelfEncapsulateField.compiler_errors_update={0} contains compiler errors. This may affect field access update.
SelfEncapsulateField.type_not_resolveable=The type of the selected field cannot be resolved. May be an import statement is missing.
SelfEncapsulateField.cannot_analyze_selected_field=Cannot analyze selected field ''{0}''
SelfEncapsulateField.checking_preconditions=Checking preconditions
SelfEncapsulateField.searching_for_cunits=Searching for affected compilation units
SelfEncapsulateField.analyzing=Analyzing
SelfEncapsulateField.create_changes=Create changes
SelfEncapsulateField.change_visibility=Change visibility to private
SelfEncapsulateField.add_setter=Add Setter method
SelfEncapsulateField.add_getter=Add Getter method

#-- inline temp ------------------------------------------------------
InlineTempRefactoring.name=Inline local variable
InlineTempRefactoring.syntax_errors=This file has syntax errors - please fix them first
InlineTempRefactoring.select_temp=A local variable declaration or reference must be selected to activate this refactoring
InlineTempRefactoring.method_parameter=Cannot inline method parameters
InlineTempRefactoring.exceptions_declared=Cannot inline exceptions declared in \'catch\' clauses
InlineTempRefactoring.not_initialized=Local variable ''{0}'' is not initialized at declaration
InlineTempRefactoring.assigned_more_once=Local variable ''{0}'' is assigned to more than once
InlineTempRefactoring.preview=Creating preview
InlineTempRefactoring.inline=Inline local variable
InlineTempRefactoring.inline_edit_name=Inline local variable: 
InlineTempRefactoring.remove_edit_name=Remove local variable: 
InlineTempRefactoring.Array_vars_initialized=Array variables initialized with constants cannot be inlined.
InlineTempRefactoring.for_initializers=Cannot inline variables declared in the initializer list of a \'for\' statement.

#-- extract temp ------------------------------------------------------
ExtractTempRefactoring.name=Extract Local Variable
ExtractTempRefactoring.select_expression=An expression must be selected to activate this refactoring
ExtractTempRefactoring.syntax_error=This file has syntax errors - please fix them first
ExtractTempRefactoring.explicit_constructor=Code from explicit constructor calls cannot be extracted to a variable
ExtractTempRefactoring.expression_in_method=An expression used in a method must be selected to activate this refactoring
ExtractTempRefactoring.no_void=Cannot extract an expression of type \'void\'
ExtractTempRefactoring.null_literals=Cannot extract single null literals
ExtractTempRefactoring.array_initializer=Operation not applicable to an array initializer
ExtractTempRefactoring.assignment=Cannot extract assignment that is part of another expression
ExtractTempRefactoring.single_conditional_expression=Currently no support to extract a single conditional expression
ExtractTempRefactoring.convention=By convention, all names of local variables start with lowercase letters
ExtractTempRefactoring.checking_preconditions=Checking preconditions
ExtractTempRefactoring.preview=Preparing preview
ExtractTempRefactoring.extract_temp=Extract Temp
ExtractTempRefactoring.update_imports=Update imports
ExtractTempRefactoring.declare_local_variable=Declare local variable
ExtractTempRefactoring.replace=Replace expression with a local variable reference
ExtractTempRefactoring.name_in_new=Cannot extract this name - try selecting the whole instance creation expression
ExtractTempRefactoring.names_in_declarations=Names used in declarations are not expressions. An expressions must be selected to activate this refactoring.
ExtractTempRefactoring.assigned_to=Selected expression is assigned to. Extracting may change the program\'s semantics

#-- extract constant --------------------------------------------------
ExtractConstantRefactoring.name=Extract Constant
ExtractConstantRefactoring.select_expression=An expression must be selected to activate this refactoring
ExtractConstantRefactoring.syntax_error=This file has syntax errors - please fix them first
ExtractConstantRefactoring.declare_constant=Declare constant
ExtractConstantRefactoring.update_imports=Update imports
ExtractConstantRefactoring.replace=Replace expression with a constant reference
ExtractConstantRefactoring.preview=Preparing preview
ExtractConstantRefactoring.field_exists=Field ''{0}'' already exists
ExtractConstantRefactoring.no_void=Cannot extract an expression of type \'void\'
ExtractConstantRefactoring.null_literals=Cannot extract single null literals
ExtractConstantRefactoring.not_load_time_constant=Cannot extract this expression - it is not a valid static constant
ExtractConstantRefactoring.extract_constant=Extract Constant
ExtractConstantRefactoring.convention=By convention, names of class constants do not contain lowercase letters
ExtractConstantRefactoring.checking_preconditions=Checking preconditions
ExtractConstantRefactoring.rename=Rename Constant

#######################################
# org.eclipse.jdt.internal.core.refactoring.rename
#######################################
RenameCompilationUnitRefactoring.name=Rename ''{0}'' to ''{1}''
RenameCompilationUnitRefactoring.not_parsed={0} has syntax errors. No references will be updated if you proceed
RenameCompilationUnitRefactoring.not_parsed_1={0} has syntax errors.
RenameCompilationUnitRefactoring.same_name=The same name chosen

RenameFieldRefactoring.name=Rename field ''{0}'' to ''{1}''
RenameFieldRefactoring.hiding=After renaming, the field ''{0}'' will be hidden in the scope of the field ''{1}'' declared in type ''{2}''
RenameFieldRefactoring.hiding2=After renaming, the field named ''{0}'' declared in type ''{1}'' will be hidden in the scope of the field ''{2}''
RenameFieldRefactoring.another_name=Choose another name.
RenameFieldRefactoring.checking=Checking preconditions...
RenameFieldRefactoring.field_already_defined=Field with this name is already defined.
RenameFieldRefactoring.searching=Searching for references...
RenameFieldRefactoring.deleted=The selected field has been deleted from ''{0}''
RenameFieldRefactoring.assert.new_name=new name
RenameFieldRefactoring.already_exists=Method ''{0}'' already exists in ''{1}''
RenameFieldRefactoring.overridden=Method ''{0}'' is overridden or overrides another method
RenameFieldRefactoring.overridden_or_overrides=Method ''{0}'' is overridden or overrides another method
RenameFieldRefactoring.Rename_Field=Rename Field
RenameFieldRefactoring.Update_getter_occurrence=Update getter occurrence
RenameFieldRefactoring.Update_setter_occurrence=Update setter occurrence
RenameFieldRefactoring.searching_for_text_matches=searching for text matches
RenameFieldRefactoring.Update_field_declaration=Update field declaration
RenameFieldRefactoring.Update_field_reference=Update field reference
RenameFieldRefactoring.should_start_lowercase=By convention, Java instance field names usually start with a lowercase letter.
RenameFieldRefactoring.declared_in_supertype=Cannot be renamed because it is declared in a supertype

RenamePackageRefactoring.another_name=Choose another name.
RenamePackageRefactoring.checking=Checking preconditions...
RenamePackageRefactoring.creating_change=Preparing preview...
RenamePackageRefactoring.package_exists=Package already exists
RenamePackageRefactoring.searching=Searching for references...
RenamePackageRefactoring.update_reference=update package reference
RenamePackageRefactoring.name=Rename package ''{0}'' to ''{1}''
RenamePackageRefactoring.aleady_exists=Package ''{0}'' already exists in this project in folder ''{1}''

RenameMethodInInterfaceRefactoring.already_defined=A related type declares a method with the new name (and same number of parameters)
RenameMethodInInterfaceRefactoring.no_class_method=Not applicable to class methods
RenameMethodInInterfaceRefactoring.special_case=Cannot rename this method because it is a special case (see the language specification section 9.2 for details)

RenameMethodRefactoring.name=Rename method ''{0}'' to ''{1}''
RenameMethodRefactoring.no_binary=Related method ''{0}'' (declared in ''{1}'') is binary. Refactoring cannot be performed.
RenameMethodRefactoring.no_constructors=Not applicable to constructors
RenameMethodRefactoring.no_native=Renaming native methods will cause an unsatisfied link error on runtime.
RenameMethodRefactoring.no_native_1=Related method ''{0}'' (declared in ''{1}'') is native. Renaming will cause an UnsatisfiedLinkError on runtime.
RenameMethodRefactoring.no_read_only=Related method ''{0}'' (declared in ''{1}'') is read-only. Refactoring cannot be performed.
RenameMethodRefactoring.not_in_model=Related method ''{0}'' (declared in ''{1}'') does not exist in the model.
RenameMethodRefactoring.same_name=Same name chosen
RenameMethodRefactoring.special_case=This method is a special case - renaming might change program''s behavior.

RenamePrivateMethodRefactoring.only_private=Only applicable to private methods
RenamePrivateMethodRefactoring.hierarchy_defines=''{0}'' or a type in its hierarchy defines a method named ''{1}''
RenamePrivateMethodRefactoring.update=Update method reference

RenameStaticMethodRefactoring.no_private=must not be private
RenameStaticMethodRefactoring.only_static=must be static
RenameStaticMethodRefactoring.hierachy_declares=Hierarchy declares a method named ''{0}'' with the same number of parameters.

RenameVirtualMethodRefactoring.no_private=not applicable to private methods
RenameVirtualMethodRefactoring.no_static=not applicable to static methods
RenameVirtualMethodRefactoring.only_class_methods=only applicable to class methods
RenameVirtualMethodRefactoring.requieres_renaming_native=Renaming ''{0}'' requires renaming a native method. Renaming will cause {1} on runtime.
RenameVirtualMethodRefactoring.hierarchy_declares1=Hierarchy declares a method ''{0}'' with the same number of parameters.

RenameMethodRefactoring.rename=Rename Method
RenameMethodRefactoring.update_occurrence=Update method occurrence
RenameMethodRefactoring.update_declaration=Update method declaration
RenameMethodRefactoring.deleted=The selected method has been deleted from ''{0}''

RenameTypeRefactoring.checking=Checking preconditions...
RenameTypeRefactoring.choose_another_name=Please choose another name.
RenameTypeRefactoring.creating_change=Preparing preview...
RenameTypeRefactoring.rename_constructor=rename constructor
RenameTypeRefactoring.searching=Searching for references...
RenameTypeRefactoring.special_case=It is a special case
RenameTypeRefactoring.update_reference=update type reference
RenameTypeRefactoring.name=Rename type ''{0}'' to ''{1}''
RenameTypeRefactoring.enclosed=Type ''{0}'' is enclosed in a type named ''{1}''
RenameTypeRefactoring.encloses=Type ''{0}'' encloses a type named ''{1}''
RenameTypeRefactoring.exists=Type named ''{0}'' already exists in package ''{1}''
RenameTypeRefactoring.imported=Type named ''{0}'' is imported (single-type-import) in ''{1}'' (a compilation unit must not import and declare a type with the same name)
RenameTypeRefactoring.member_type_exists=Another member type named ''{0}'' already exists in ''{1}''
RenameTypeRefactoring.enclosed_type_native=A type enclosed in type ''{0}'' declares a native method. Renaming will cause an unsatisfied link error on runtime.
RenameTypeRefactoring.name_conflict1=Name conflict with type ''{0}'' in ''{1}''
RenameTypeRefactoring.name_conflict2=Name conflict with type ''{0}'' declared in ''{1}''
RenameTypeRefactoring.searching_text=searching for text matches
RenameTypeRefactoring.update=Type declaration update
RenameTypeRefactoring.does_not_exist=Type ''{0}'' does not exist in the saved version of ''{1}''
RenameTypeRefactoring.will_not_rename=Compilation unit will not be renamed
RenameTypeRefactoring.local_type=Local Type declared inside ''{0}'' is named {1}
RenameTypeRefactoring.member_type=Member Type declared inside ''{0}'' is named {1}
RenameTypeRefactoring.another_type=Another type named ''{0} is referenced in ''{1}''

TextMatchFinder.javadoc=text reference update in Javadoc
TextMatchFinder.comment=text reference update in a comment
TextMatchFinder.string=text reference update in a string literal
TextMatchFinder.searching=searching for text matches in:

RippleMethodFinder.assert.contain=! visitedTypes.contains(type)
RippleMethodFinder.assert.second=second condition
RippleMethodFinder.analizing_hierarchy=analyzing hierarchy

RefactoringAnalyzeUtil.name_collision=Name collision with name 

RenameTempRefactoring.must_select_local=A local variable declaration or reference must be selected to activate this refactoring
RenameTempRefactoring.only_in_methods=Currently, only local variables declared in methods can be renamed
RenameTempRefactoring.lowercase=By convention, all names of local variables start with lowercase letters
RenameTempRefactoring.rename=Rename Local Variable
RenameTempRefactoring.changeName=Rename local variable:''{0}'' to: ''{1}''

MethodChecks.overrides=The selected method overrides method ''{0}'' declared in type ''{1}''.
MethodChecks.implements=The selected method is an implementation of method ''{0}'' declared in type ''{1}''

RenameJavaProjectRefactoring.rename=Rename Java project ''{0}'' to:''{1}''
RenameJavaProjectRefactoring.already_exists=A project with that name already exists
RenameJavaProjectRefactoring.read_only=Project ''{0}'' is marked as read-only

RenamePackageRefactoring.different_case=A resource exists with a different case
RenamePackageRefactoring.searching_text=searching for text matches
RenamePackageRefactoring.Packagered_only=Package ''{0}'' is read-only
RenamePackageRefactoring.resource_read_only=Resource corresponding to package ''{0}'' is read-only
RenamePackageRefactoring.contains_type=Package ''{0}'' already contains a type named ''{1}''

RenameResourceRefactoring.Internal_Error=Internal Error
RenameResourceRefactoring.alread_exists=A file or folder with this name already exists
RenameResourceRefactoring.invalidName=This is an invalid name for a file or folder
RenameResourceRefactoring.rename=Rename resource ''{0}'' to ''{1}''

RenameSourceFolderRefactoring.blank=Name must not start or end with a blank
RenameSourceFolderRefactoring.invalid_name=This is an invalid name for a file or folder
RenameSourceFolderRefactoring.already_exists=An element with this name already exists
RenameSourceFolderRefactoring.alread_exists=An element with this name already exists
RenameSourceFolderRefactoring.rename=Rename Source Folder ''{0}'' to ''{1}''
RenameSourceFolderRefactoring.read_only=Source folder ''{0}'' is marked as read-only

#######################################
# org.eclipse.jdt.internal.core.refactoring.reorg
#######################################
MoveRefactoring.move_elements=Move elements
MoveRefactoring.reorganize_elements=Reorganize elements

ReorgRefactoring.assert.destination=destination not specified
ReorgRefactoring.reorganize_elements=reorganize elements
ReorgRefactoring.assert.whyhere=not expected to get here

DeleteRefactoring.delete_resources=Delete resources
DeleteRefactoring.delete=Delete
DeleteRefactoring.read_only=Selected element ''{0}'' (or one or its sub-elements) is marked as read-only

MoveCuUpdateCreator.update_imports=update imports
MoveCuUpdateCreator.searching=searching for references to types in 
MoveCuUpdateCreator.update_references=update references

CopyRefactoring.copy_elements=Copy elements
CopyRefactoring.cu.copyOf1=CopyOf{0}
CopyRefactoring.cu.copyOfMore=Copy_{0}_of_{1}
CopyRefactoring.resource.copyOf1=Copy of {0}
CopyRefactoring.resource.copyOfMore=Copy ({0}) of {1}
CopyRefactoring.package.copyOf1=copyof.{0}
CopyRefactoring.package.copyOfMore=copy{0}of.{1}

#######################################
# org.eclipse.jdt.internal.core.refactoring.structure
#######################################
PullUpRefactoring.Pull_Up=Pull Up
PullUpRefactoring.same_declaring_type=All selected elements must be declared in the same type
PullUpRefactoring.only_fields_and_methods=Pull up is allowed only on fields and methods
PullUpRefactoring.elements_do_not_exist=Pull up is not allowed on elements that do not exist
PullUpRefactoring.no_binary_elements=Pull up is not allowed on binary elements
PullUpRefactoring.no_read_only_elements=Pull up is not allowed on read-only elements
PullUpRefactoring.no_unknown_structure=Pull up is not allowed on elements with unknown structure
PullUpRefactoring.no_static_elements=Pull up is not allowed on static elements
PullUpRefactoring.no_constructors=Pull up is not allowed on constructors
PullUpRefactoring.no_native_methods=Pull up is not allowed on native methods
PullUpRefactoring.no_interface_members=Pull up is not allowed on interface members
PullUpRefactoring.no_java.lang.Object=Pull up is not allowed on elements declared in java.lang.Object
PullUpRefactoring.no_binary_types=Pull up is not allowed on elements declared in binary types
PullUpRefactoring.no_read_only_types=Pull up is not allowed on elements declared in read-only types
PullUpRefactoring.not_this_type=Pull up is not allowed on elements declared in this type
PullUpRefactoring.final_fields=Pulling up final fields will result in compilation errors if they are not initialized on creation or in constructors
PullUpRefactoring.checking_referenced_elements=Checking referenced elements
PullUpRefactoring.does_not_exist=Element {0} does not exist in the saved version of the file
PullUpRefactoring.type_not_accessible=Type ''{0}'' referenced in one of the pulled elements is not accessible from type ''{1}''
PullUpRefactoring.field_not_accessible=Field ''{0}'' referenced in one of the pulled elements is not accessible from type ''{1}''
PullUpRefactoring.method_not_accessible=Method ''{0}'' referenced in one of the pulled elements is not accessible from type ''{1}''
PullUpRefactoring.different_method_return_type=Method ''{0}'' declared in type''{1}'' has a different return type than its pulled up counterpart, which will result in compile errors if you proceed
PullUpRefactoring.different_field_type=Field ''{0}'' declared in type ''{1}'' has a different type than its pulled up counterpart
PullUpRefactoring.static_method=Method ''{0}'' declared in type ''{1}'' is \'static\', which will result in compile errors if you proceed
PullUpRefactoring.lower_visibility=Method ''{0}'' declared in type ''{1}'' has visibility lower than \'protected\', which will result in compile errors if you proceed
PullUpRefactoring.preview=Preparing preview

MemberChecksUtil.signature_exists=Method ''{0}'' (with the same signature) already exists in type ''{1}'', which will result in compile errors if you proceed
MemberChecksUtil.same_param_count=Method ''{0}'' (with the same number of parameters) already exists in type ''{1}''
MemberChecksUtil.field_exists=Field ''{0}'' already exists in type ''{1}'', which will result in compile errors if you proceed

ChangeSignatureRefactoring.modify_Parameters=Change Method Signature
ChangeSignatureRefactoring.restructure_parameters=Restructure parameters
ChangeSignatureRefactoring.checking_preconditions=Checking preconditions
ChangeSignatureRefactoring.method_deleted=The selected method has been deleted from ''{0}''
ChangeSignatureRefactoring.native=Method ''{0}'' declared in type ''{1}'' is native.  Reordering parameters will cause UnsatisfiedLinkError on runtime if you do not update your native libraries
ChangeSignatureRefactoring.duplicate_name=Duplicate parameter name: {0}

MoveMembersRefactoring.Move_Members=Move Members
MoveMembersRefactoring.same_type=All selected elements must be declared in the same type
MoveMembersRefactoring.Checking_preconditions=Checking preconditions
MoveMembersRefactoring.interface_fields=Currently, only fields declared in an interface can be moved to another interface
MoveMembersRefactoring.interface_members=Currently, members declared in an interface can be moved only to another interface
MoveMembersRefactoring.static_declaration=Static members can be declared only in top level or static types
MoveMembersRefactoring.public=public
MoveMembersRefactoring.protected=protected
MoveMembersRefactoring.private=private
MoveMembersRefactoring.package-visible=package-visible
MoveMembersRefactoring.fields_methods=Move allowed only on fields and methods
MoveMembersRefactoring.exist=Move is not allowed on elements that do not exist
MoveMembersRefactoring.binary_elements=Move is not allowed on binary elements
MoveMembersRefactoring.read_only_elements=Move is not allowed on read-only elements
MoveMembersRefactoring.structure=Move is not allowed on elements with unknown structure
MoveMembersRefactoring.interface_methods=Move is not allowed on interface methods
MoveMembersRefactoring.static_methods=Move is allowed only on static methods
MoveMembersRefactoring.static_elements=Move is allowed only on static elements (and interface fields)
MoveMembersRefactoring.constructors=Move is not allowed on constructors
MoveMembersRefactoring.Object=Move is not allowed on members declared in java.lang.Object
MoveMembersRefactoring.binary=Pull up is not allowed on members of binary types
MoveMembersRefactoring.read_only=Pull up is not allowed on members of read-only types
MoveMembersRefactoring.move_members=Move members
MoveMembersRefactoring.analyzing=Analyzing
MoveMembersRefactoring.Copy=Copy 
MoveMembersRefactoring.delete=Delete 
MoveMembersRefactoring.convert=Convert reference to fully qualified
MoveMembersRefactoring.not_found=Destination type ''{0}'' not be found
MoveMembersRefactoring.same=Destination and source types are the same (''{0}'')
MoveMembersRefactoring.not_exist=Destination type ''{0}'' does not exist
MoveMembersRefactoring.dest_binary=Destination type ''{0}'' is binary
MoveMembersRefactoring.native=Moved method ''{0}'' is native. You will need to update native libraries
MoveMembersRefactoring.moved_field=Moved field ''{0}'' is {1} and will not be visible from ''{2}''
MoveMembersRefactoring.accessed_field=Accessed field ''{0}'' is {1} and will not be visible from ''{2}''
MoveMembersRefactoring.moved_method=Moved method ''{0}'' is {1} and will not be visible from ''{2}''
MoveMembersRefactoring.accessed_method=Accessed method ''{0}'' is {1} and will not be visible from ''{2}''
MoveMembersRefactoring.moved_type=Moved type ''{0}'' is {1} and will not be visible from ''{2}''
MoveMembersRefactoring.accessed_type=Accessed type ''{0}'' is {1} and will not be visible from ''{2}''

MoveRefactoring.warning.typeWillNotBeAccessible=Type ''{0}'' will not be accessible after moving.
MoveRefactoring.warning.containsReferencesToTypeThatWillNotBeVisible=''{0}'' contains references to a type that will not be visible after moving.
MoveRefactoring.scanning_qualified_names=Scanning for qualified names in non Java files...

QualifiedNameFinder.update_name=Update fully qualified name

#######################################
# org.eclipse.jdt.internal.core.refactoring.surround
#######################################

SurroundWithTryCatchRefactoring.name=Surround with try/catch block
SurroundWithTryCatchAnalyzer.doesNotCover=Selection does not cover a set of statements. Extend selection to a valid range using the "Expand Selection With" actions from the Edit menu.
SurroundWithTryCatchAnalyzer.doesNotContain=Selection does not contain statements from a method body or static initializer.
SurroundWithTryCatchAnalyzer.noUncaughtExceptions=No uncaught exceptions are thrown by the selected code.
SurroundWithTryCatchAnalyzer.onlyStatements=Can only surround statements with a try/catch block.
SurroundWithTryCatchAnalyzer.cannotHandleSuper=Cannot surround a super constructor call.
SurroundWithTryCatchAnalyzer.cannotHandleThis=Cannot surround a constructor invocation.
SurroundWithTryCatchAnalyzer.compile_errors=Compilation errors prevent analyzing the selected code. Fix the errors first.

#######################################
# org.eclipse.jdt.internal.core.refactoring.util
#######################################

CommentAnalyzer.internal_error=Internal error during precondition checking.
CommentAnalyzer.ends_inside_comment=Selection ends inside a comment.
CommentAnalyzer.starts_inside_comment=Selection starts inside a comment.

StatementAnalyzer.doesNotCover= The selection does not cover a set of statements or an expression. Extend selection to a valid range using the "Expand Selection With" actions from the Edit menu.
StatementAnalyzer.beginning_of_selection=The beginning of the selection contains characters that do not belong to a statement.
StatementAnalyzer.end_of_selection=The end of the selection contains characters that do not belong to a statement.
StatementAnalyzer.do_body_expression=Operation not applicable to a do statement's body and expression.
StatementAnalyzer.for_initializer_expression=Operation not applicable to a for statement's initializer and expression part.
StatementAnalyzer.for_expression_updater=Operation not applicable to a for statement's expression and updater part.
StatementAnalyzer.for_updater_body=Operation not applicable to a for statement's updater and body part.
StatementAnalyzer.catch_argument=Operation is not applicable to a catch block's argument declaration.
StatementAnalyzer.while_expression_body=Operation not applicable to a while statement's expression and body.
StatementAnalyzer.try_statement=Selection must either cover whole try statement or parts of try, catch, or finally block.
StatementAnalyzer.switch_statement=Selection must either cover whole switch statement or parts of a single case block.
StatementAnalyzer.synchronized_statement=Selection must either cover whole synchronized statement or parts of the synchronized block.

CodeAnalyzer.array_initializer=Operation not applicable to an array initializer.
JavaElementUtil.initializer_in=initializer in 
JavaElementUtil.initializer=initializer

#######################################
# other
#######################################
CopyResourceString.copy=Copy resource ''{0}'' to ''{1}''

RenameAnalyzeUtil.shadows=Problem in ''{0}''. Another name shadows access to the renamed element
CopyRefactoring.update_ref=Update Type Reference
CopyRefactoring.searching=Searching
CompositeChange.performingChangesTask.name=Performing changes...
CodeRefactoringUtil.error.message=Compilation errors in method ''{0}'' prevent analyzing the body of the method. Please fix the errors first.
InlineTemRefactoring.error.message.nulLiteralsCannotBeInlined=Null literals cannot be inlined
InlineTemRefactoring.error.message.fieldsCannotBeInlined=Cannot inline fields
RenameMethodRefactoring.taskName.checkingPreconditions=Checking preconditions...
RenameMethodRefactoring.taskName.searchingForReferences=Searching for references...

PushDownRefactoring.name=Push Down
PushDownRefactoring.no_common_type=Selected elements do not have a common delcaring type
PushDownRefactoring.only_fields_and_methods=Only fields and methods can be pushed down
PushDownRefactoring.not_exists=One or more of the elements does not exist
PushDownRefactoring.binary=Binary members cannot be pulled down
PushDownRefactoring.read_only=Read only elements cannot be pulled down
PushDownRefactoring.unknown_structure=Elements with unknown structure cannot be pulled down
PushDownRefactoring.static=Static members cannot be pulled down
PushDownRefactoring.constructors=Constructors cannot be pulled down
PushDownRefactoring.native=Native methods cannot be pulled down
PushDownRefactoring.no_subclasses=Class ''{0}'' does not have any modifiable non-anonymous subclasses to which members could be pushed down
PushDownRefactoring.not_in_saved=One more more of the selected members does not exist in the saved version of the file
PushDownRefactoring.interface_members=Pushing down interface members is not supported
PushDownRefactoring.members_of_binary=Pushing down members declared in binary types is not supported
PushDownRefactoring.members_of_read-only=Pushing down members declared in read-only types is not supported
PushDownRefactoring.calculating=Calculating required members
PushDownRefactoring.referenced=Pushed down member ''{0}'' is referenced by ''{1}''
PushDownRefactoring.checking=Checking referenced elements
PushDownRefactoring.type_not_accessible=Type ''{0}'' referenced in one of the pushed elements is not accessible from type ''{1}''
PushDownRefactoring.field_not_accessible=Field ''{0}'' referenced in one of the pulled elements is not accessible from type ''{1}''
PushDownRefactoring.method_not_accessible=Method ''{0}'' referenced in one of the pulled elements is not accessible from type ''{1}''
PushDownRefactoring.gets_instantiated=Class ''{0}'' cannot be made abstract because it gets instantiated
PushDownRefactoring.preview=Creating preview...
PushDownRefactoring.push_down_members=Push down class member(s)
PushDownRefactoring.initializer=initializer
PushDownRefactoring.creating_preview=Creating preview...

ChangeSignatureRefactoring.invalid_return_type=''{0}'' is not a valid return type name
ChangeSignatureRefactoring.default_value=Enter the default value for parameter ''{0}''
ChangeSignatureRefactoring.invalid_expression=''{0}'' is not a valid expression
ChangeSignatureRefactoring.parameter_type=Enter the type for parameter ''{0}''
ChangeSignatureRefactoring.invalid_type_name=''{0}'' is not a valid parameter type name
ChangeSignatureRefactoring.unchanged=Method signature and return type are unchanged.
ChangeSignatureRefactoring.parameter_used=Parameter ''{0}'' is used in method ''{1}'' declared in type ''{2}''
ChangeSignatureRefactoring.anonymous_subclass=anonymous subclass of ''{0}''
ChangeSignatureRefactoring.non-virtual=Changing visibility to \'private\' will make this method non-virtual, which may affect the program\'s behavior
ChangeSignatureRefactoring.already_has=Method ''{0}'' already has a parameter named ''{1}''
ChangeSignatureRefactoring.preview=Preparing preview
ChangeSignatureRefactoring.modify_parameters=Modify parameters

MoveInnerToTopRefactoring.names_start_lowercase=By convention, all names of instance fields and local variables start with lowercase letters
MoveInnerToTopRefactoring.already_declared=A field named ''{0}'' is already declared in type ''{1}'' 
MoveInnerToTopRefactoring.only_nested_types=This refactoring is available only on nested types.
MoveInnerToTopRefactoring.deleted=The selected type has been deleted from ''{0}''
MoveInnerToTopRefactoring.compilation_Unit_exists=Compilation Unit named ''{0}'' already exists in package ''{1}''
MoveInnerToTopRefactoring.name_used=Name ''{0}'' is used as a parameter name in one of the constructors of type ''{1}'' 
MoveInnerToTopRefactoring.type_exists=Type named ''{0}'' already exists in package ''{1}''
MoveInnerToTopRefactoring.name=Move Nested Type to Top Level
MoveInnerToTopRefactoring.creating_preview=Creating change
MoveInnerToTopRefactoring.move_to_Top=Move Nested Type to Top Level
MoveInnerToTopRefactoring.update_field_access=Update field access
MoveInnerToTopRefactoring.update_method_invocation=Update method invocation
MoveInnerToTopRefactoring.add_parameter=Add parameter to constructor
MoveInnerToTopRefactoring.set_enclosing_instance_field=Set enclosing instance field
MoveInnerToTopRefactoring.add_constructor=Add constructor
MoveInnerToTopRefactoring.add_enclosing_instance_declaration=Add enclosing instance declaration
MoveInnerToTopRefactoring.delete_Unused_Modifier=Delete Unused Modifier
MoveInnerToTopRefactoring.update_Type_Reference=Update Type Reference
MoveInnerToTopRefactoring.cut_type=Cut type
MoveInnerToTopRefactoring.update_Constructor_Reference=Update Constructor Reference

InstanceMethodMover.move_method=Move instance method
InstanceMethodMover.transform_to_delegate=Transform original method to delegate to new method.
InstanceMethodMover.replace_with_delegation=Replace method body with delegation.
InstanceMethodMover.create_in_receiver=Create method in new receiver\'s class.
InstanceMethodMover.add_imports=Add needed imports for created method
InstanceMethodMover.to_local_localunsupported=Moving to within local classes is currently unsupported.
InstanceMethodMover.moving_to_same_cu_unsupported=Moving a method to a class declared within the same compilation unit is currently unsupported.
InstanceMethodMover.parameter_name_used=Parameter name ''{0}'' is already used
InstanceMethodMover.no_static_methods=This refactoring cannot be used to move static methods.
InstanceMethodMover.single_implementation=Select a single method implementation to move.
InstanceMethodMover.no_native_methods=This refactoring cannot be used to move native methods.
InstanceMethodMover.no_synchronized_methods=This refactoring cannot be used to move synchronized methods.
InstanceMethodMover.no_constructors=This refactoring cannot be used to move a constructor.
InstanceMethodMover.uses_super=The method cannot be moved, since it uses the \"super\" keyword.
InstanceMethodMover.refers_enclosing_instances=The method cannot be moved, since it refers to enclosing instances (i.e. <EnclosingClassName>.this).
InstanceMethodMover.potentially_recursive=This refactoring cannot be used to move potentially recursive methods.
InstanceMethodMover.cannot_be_moved=This method cannot be moved.

ExtractInterfaceRefactoring.no_local_types=Cannot perform Extract Interface on local types.
ExtractInterfaceRefactoring.no_anonymous_types=Cannot perform Extract Interface on anonymous types.
ExtractInterfaceRefactoring.no_member_classes=Cannot perform Extract Interface on member classes.
ExtractInterfaceRefactoring.deleted=The selected type has been deleted from ''{0}''
ExtractInterfaceRefactoring.no_Throwable=Extract Interface refactoring is not available on \"java.lang.Throwable\" and its subclasses
ExtractInterfaceRefactoring.type_exists=Type named ''{0}'' already exists in package ''{1}''
ExtractInterfaceRefactoring.compilation_Unit_exists=Compilation Unit named ''{0}'' already exists in package ''{1}''
ExtractInterfaceRefactoring.internal_Error=Internal Error. Please see log for details.
ExtractInterfaceRefactoring.name=Extract Interface
ExtractInterfaceRefactoring.analyzing...=Analyzing...
ExtractInterfaceRefactoring.delete_method=Delete extracted method
ExtractInterfaceRefactoring.delete_field=Delete extracted field
ExtractInterfaceRefactoring.update_Type_Declaration=Update Type Declaration

UseSupertypeWherePossibleUtil.update_reference=Update reference
UseSupertypeWherePossibleUtil.adding_import=Adding import to ''{0}''

PullUpRefactoring.calculating_required=Calculating required members
PullUpRefactoring.multi_declaration=Field ''{0}'' is declared in a multi declaration. Pulling up is currently not supported.
PullUpRefactoring.gets_instantiated=Class ''{0}'' cannot be made abstract because it gets instantiated
PullUpRefactoring.Field_declared_in_class=Field ''{0}'' is declared in class ''{1}''. Pulling it up may result in changed program semantics.
PullUpRefactoring.methodis_declared_in_class=Method ''{0}'' is declared in class ''{1}''. Pulling it up may result in changed program semantics.
PullUpRefactoring.field_cannot_be_accessed=Field ''{0}'' cannot be accessed from ''{1}''
PullUpRefactoring.method_cannot_be_accessed=Method ''{0}'' cannot be accessed from ''{1}''
PullUpRefactoring.pull_up_class_members=Pull up class member(s)
PullUpRefactoring.creating_preview=Creating preview...

UseSupertypeWherePossibleRefactoring.deleted=The selected type has been deleted from ''{0}''
UseSupertypeWherePossibleRefactoring.unavailable_on_Throwable=Use Supertype Where Possible refactoring is not available on \"java.lang.Throwable\" and its subclasses
UseSupertypeWherePossibleRefactoring.name=Use Supertype Where Possible
UseSupertypeWherePossibleRefactoring.analyzing...=Analyzing...

ImportEditManager.update_Imports=Update Imports

MoveInstanceMethodRefactoring.method_declaration=A method declaration must be selected in order to activate this refactoring.
MoveInstanceMethodRefactoring.name=Move Instance Method

CopyPackageFragmentRootChange.copy=Copy Package Fragment Root ''{0}'' to project ''{1}''

DeletePackageFragmentRootChange.delete=Delete package fragment root ''{0}''

MovePackageFragmentRootChange.move=Move Package Fragment Root ''{0}'' to project ''{1}''

PromoteTempToFieldRefactoring.name=Promote Local Variable to Field
PromoteTempToFieldRefactoring.select_declaration=Select a declaration or a reference to a local variable.
PromoteTempToFieldRefactoring.only_declared_in_methods=Currently, only local variables declared in methods can be converted to fields.
PromoteTempToFieldRefactoring.method_parameters=Cannot convert method parameters to fields.
PromoteTempToFieldRefactoring.exceptions=Cannot convert exceptions declared in catch clauses to fields.
PromoteTempToFieldRefactoring.uses_types_declared_locally=Cannot promote this local variable to a field because it uses types or variables declared locally in the method
PromoteTempToFieldRefactoring.cannot_promote=Cannot promote this local variable to a field
PromoteTempToFieldRefactoring.uses_type_declared_locally=Cannot promote this local variable to a field because it uses a type declared locally in the method
PromoteTempToFieldRefactoring.Name_conflict=Name conflict with name ''{0}'' used in ''{1}''
PromoteTempToFieldRefactoring.Name_conflict_with_field=Name conflict with existing field
PromoteTempToFieldRefactoring.editName=Promote local variable to field

ConvertAnonymousToNestedRefactoring.name=Convert Anonymous to Inner
ConvertAnonymousToNestedRefactoring.place_caret=Place the caret inside an anonymous inner class
ConvertAnonymousToNestedRefactoring.type_exists=Nested type with that name already exists
ConvertAnonymousToNestedRefactoring.another_name=Choose another name
ConvertAnonymousToNestedRefactoring.name_hides=Class name hides an enclosing type name
ConvertAnonymousToNestedRefactoring.edit_name=Convert anonymous inner class to a nested class

InlineConstantRefactoring.members_declared_in_anonymous=Cannot inline since the initializer to be inlined refers to members declared in an anonymous class scope (currently unsupported).
InlineConstantRefactoring.Inline=Inline Constant
InlineConstantRefactoring.syntax_errors=This file has syntax errors - please fix them first
InlineConstantRefactoring.local_anonymous_unsupported=Inlining of constants defined in local or anonymous classes is currently not supported.
InlineConstantRefactoring.static_final_field=A static final field must be selected
InlineConstantRefactoring.blank_finals=Inline Constant cannot inline blank finals
InlineConstantRefactoring.binary_file=Cannot inline this constant, since it is declared in a binary file.
InlineConstantRefactoring.preview=Generating preview ...
InlineConstantRefactoring.inline=Inline Constant
InlineConstantRefactoring.remove_declaration=Remove constant declaration
InlineConstantRefactoring.name=Inline Constant
InlineConstantRefactoring.source_code_unavailable=References in ''{0}'' cannot be inlined since source code is not available

TargetProvider.field_initializer=Cannot inline call that is used as a field initializer.
