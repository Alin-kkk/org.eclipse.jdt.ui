/*
 * (c) Copyright IBM Corp. 2000, 2001.
 * All Rights Reserved.
 */
package org.eclipse.jdt.internal.corext.refactoring.reorg;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.eclipse.core.resources.IContainer;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.NullProgressMonitor;

import org.eclipse.jdt.core.ICompilationUnit;
import org.eclipse.jdt.core.IJavaElement;
import org.eclipse.jdt.core.IJavaProject;
import org.eclipse.jdt.core.IMethod;
import org.eclipse.jdt.core.IPackageFragment;
import org.eclipse.jdt.core.IPackageFragmentRoot;
import org.eclipse.jdt.core.IType;
import org.eclipse.jdt.core.JavaConventions;
import org.eclipse.jdt.core.JavaCore;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jdt.core.search.IJavaSearchConstants;
import org.eclipse.jdt.core.search.IJavaSearchScope;
import org.eclipse.jdt.core.search.ISearchPattern;
import org.eclipse.jdt.core.search.SearchEngine;

import org.eclipse.jdt.internal.corext.refactoring.Assert;
import org.eclipse.jdt.internal.corext.refactoring.CompositeChange;
import org.eclipse.jdt.internal.corext.refactoring.NullChange;
import org.eclipse.jdt.internal.corext.refactoring.RefactoringCoreMessages;
import org.eclipse.jdt.internal.corext.refactoring.RefactoringSearchEngine;
import org.eclipse.jdt.internal.corext.refactoring.SearchResult;
import org.eclipse.jdt.internal.corext.refactoring.SearchResultGroup;

import org.eclipse.jdt.internal.corext.refactoring.base.IChange;
import org.eclipse.jdt.internal.corext.refactoring.base.Refactoring;
import org.eclipse.jdt.internal.corext.refactoring.base.RefactoringStatus;
import org.eclipse.jdt.internal.corext.refactoring.changes.AddToClasspathChange;
import org.eclipse.jdt.internal.corext.refactoring.changes.CopyCompilationUnitChange;
import org.eclipse.jdt.internal.corext.refactoring.changes.CopyPackageChange;
import org.eclipse.jdt.internal.corext.refactoring.changes.CopyResourceChange;
import org.eclipse.jdt.internal.corext.refactoring.nls.changes.CreateTextFileChange;
import org.eclipse.jdt.internal.corext.refactoring.rename.UpdateTypeReferenceEdit;
import org.eclipse.jdt.internal.corext.refactoring.util.DebugUtils;
import org.eclipse.jdt.internal.corext.refactoring.util.ResourceUtil;
import org.eclipse.jdt.internal.corext.refactoring.util.TextChangeManager;
import org.eclipse.jdt.internal.corext.refactoring.util.WorkingCopyUtil;
import org.eclipse.jdt.internal.corext.textmanipulation.SimpleTextEdit;

public class CopyRefactoring extends ReorgRefactoring {

	private Set fAutoGeneratedNewNames;
	
	public CopyRefactoring(List elements){
		super(elements);
		fAutoGeneratedNewNames=  new HashSet(2);
	}
	
	/* non java-doc
	 * @see IRefactoring#getName()
	 */
	public String getName() {
		return RefactoringCoreMessages.getString("CopyRefactoring.copy_elements"); //$NON-NLS-1$
	}
	
	/* non java-doc
	 * @see Refactoring#checkInput(IProgressMonitor)
	 */
	public final RefactoringStatus checkInput(IProgressMonitor pm) throws JavaModelException {
		pm.beginTask("", 1); //$NON-NLS-1$
		try{
			return new RefactoringStatus();
		} finally{
			pm.done();
		}	
	}
	
	/* non java-doc
	 * @see ReorgRefactoring#isValidDestinationForCusAndFiles(Object)
	 */
	boolean isValidDestinationForCusAndFiles(Object dest) throws JavaModelException {
		return getDestinationForCusAndFiles(dest) != null;
	}
	
	//-----
	private static boolean isNewNameOk(IPackageFragment dest, String newName) {
		return ! dest.getCompilationUnit(newName).exists();
	}
	
	private static boolean isNewNameOk(IContainer container, String newName) {
		return container.findMember(newName) == null;
	}

	private static boolean isNewNameOk(IPackageFragmentRoot root, String newName) {
		return ! root.getPackageFragment(newName).exists() ;
	}	
	
	private String createNewName(ICompilationUnit cu, IPackageFragment dest){
		if (isNewNameOk(dest, cu.getElementName()))
			return null;
		if (! cu.getParent().equals(dest))	
			return null;
		int i= 1;
		while (true){
			String newName;
			if (i == 1)
				newName= RefactoringCoreMessages.getFormattedString("CopyRefactoring.cu.copyOf1", //$NON-NLS-1$
							cu.getElementName());
			else	
				newName= RefactoringCoreMessages.getFormattedString("CopyRefactoring.cu.copyOfMore", //$NON-NLS-1$
							new String[]{String.valueOf(i), cu.getElementName()});
			if (isNewNameOk(dest, newName) && ! fAutoGeneratedNewNames.contains(newName)){
				fAutoGeneratedNewNames.add(newName);
				return newName;
			}
			i++;
		}
	}
	
	private String createNewName(IResource res, IContainer container){
		if (isNewNameOk(container, res.getName()))
			return null;
		if (! res.getParent().equals(container))	
			return null;
		int i= 1;
		while (true){
			String newName;
			if (i == 1)
				newName= RefactoringCoreMessages.getFormattedString("CopyRefactoring.resource.copyOf1", //$NON-NLS-1$
							res.getName());
			else
				newName= RefactoringCoreMessages.getFormattedString("CopyRefactoring.resource.copyOfMore", //$NON-NLS-1$
							new String[]{String.valueOf(i), res.getName()});
			if (isNewNameOk(container, newName) && ! fAutoGeneratedNewNames.contains(newName)){
				fAutoGeneratedNewNames.add(newName);
				return newName;
			}
			i++;
		}	
	}
	
	private String createNewName(IPackageFragment pack, IPackageFragmentRoot root){
		if (isNewNameOk(root, pack.getElementName()))
			return null;
		if (! pack.getParent().equals(root))	
			return null;
			
		int i= 1;
		while (true){
			String newName;
			if (i==0)
				newName= RefactoringCoreMessages.getFormattedString("CopyRefactoring.package.copyOf1", //$NON-NLS-1$
							pack.getElementName());
			else
				newName= RefactoringCoreMessages.getFormattedString("CopyRefactoring.package.copyOfMore", //$NON-NLS-1$
							new String[]{String.valueOf(i), pack.getElementName()});
			if (isNewNameOk(root, newName) && ! fAutoGeneratedNewNames.contains(newName)){
				fAutoGeneratedNewNames.add(newName);
				return newName;
			}
			i++;
		}	
	}

	IChange createChange(IProgressMonitor pm, IPackageFragmentRoot root) throws JavaModelException{
		IResource res= root.getUnderlyingResource();
		IProject project= getDestinationForSourceFolders(getDestination());
		IJavaProject javaProject= JavaCore.create(project);
		CompositeChange result= new CompositeChange(RefactoringCoreMessages.getString("CopyRefactoring.copy_source_folder"), 2); //$NON-NLS-1$
		String newName= createNewName(res, project);
		if (newName == null )
			newName= res.getName();
		result.add(new CopyResourceChange(res, project, newName));
		if (javaProject != null)
			result.add(new AddToClasspathChange(javaProject, newName));
		return result;
	}
	
	IChange createChange(IProgressMonitor pm, IPackageFragment pack) throws JavaModelException{
		IPackageFragmentRoot root= getDestinationForPackages(getDestination());
		String newName= createNewName(pack, root);
		if (newName == null || JavaConventions.validatePackageName(newName).getSeverity() < IStatus.ERROR)
			return new CopyPackageChange(pack, root, newName);
		else{
			if (root.getUnderlyingResource() instanceof IContainer){
				IContainer dest= (IContainer)root.getUnderlyingResource();
				IResource res= pack.getCorrespondingResource();
				return new CopyResourceChange(res, dest, createNewName(res, dest));
			}else
				return new NullChange();	
		}	
	}
	
	IChange createChange(IProgressMonitor pm, IResource res) throws JavaModelException{
		IContainer dest= getDestinationForResources(getDestination());
		return new CopyResourceChange(res, dest, createNewName(res, dest));
	}
	
	IChange createChange(IProgressMonitor pm, ICompilationUnit cu) throws JavaModelException{
		Object dest= getDestinationForCusAndFiles(getDestination());
		if (dest instanceof IPackageFragment){
			String newName= createNewName(cu, (IPackageFragment)dest);
			CopyCompilationUnitChange simpleCopy= new CopyCompilationUnitChange(cu, (IPackageFragment)dest, newName);
			if (newName == null || newName.equals(cu.getElementName()) || cu.findPrimaryType() == null)
				return simpleCopy;
			
			try {
				CompositeChange composite= new CompositeChange();
				String newTypeName= newName.substring(0, newName.length() - ".java".length()); //$NON-NLS-1$
				IPath newPath= ResourceUtil.getResource(cu).getParent().getFullPath().append(newName);				
				composite.add(new CreateTextFileChange(newPath, getCopiedFileSource(pm, cu, newTypeName)));
				return composite;
			}catch(CoreException e) {
				return simpleCopy; //fallback - no ui here
			}
		}	else {
			Assert.isTrue(dest instanceof IContainer);//this should be checked before - in preconditions
			return new CopyResourceChange(ResourceUtil.getResource(cu), (IContainer)dest, createNewName(ResourceUtil.getResource(cu), (IContainer)dest));
		}		
	}

	private static String getCopiedFileSource(IProgressMonitor pm, ICompilationUnit cu, String newTypeName) throws CoreException {
		ICompilationUnit wc= WorkingCopyUtil.getNewWorkingCopy(cu);
		TextChangeManager manager= createChangeManager(pm, wc, newTypeName);
		String result= manager.get(wc).getPreviewContent();
		wc.destroy();
		return result;
	}
	
	private static TextChangeManager createChangeManager(IProgressMonitor pm, ICompilationUnit wc, String newName) throws CoreException {
		TextChangeManager manager= new TextChangeManager();
		SearchResultGroup refs= getReferences(wc, pm);
		if (refs == null)
			return manager;
		IResource resource= refs.getResource();
		IJavaElement element= JavaCore.create(resource);
		if (!(element instanceof ICompilationUnit))
			return manager;
				
		String name= RefactoringCoreMessages.getString("CopyRefactoring.update_ref"); //$NON-NLS-1$
		SearchResult[] results= refs.getSearchResults();
		for (int j= 0; j < results.length; j++){
			SearchResult searchResult= results[j];
			int offset= searchResult.getStart();
			int length= searchResult.getEnd() - searchResult.getStart();
			manager.get(wc).addTextEdit(name, new UpdateTypeReferenceEdit(offset, length, newName, wc.findPrimaryType().getElementName()));
		}
		return manager;
	}
	
	private static SearchResultGroup getReferences(ICompilationUnit wc, IProgressMonitor pm) throws JavaModelException{
		pm.subTask(RefactoringCoreMessages.getString("CopyRefactoring.searching")); //$NON-NLS-1$
		IJavaSearchScope scope= SearchEngine.createJavaSearchScope(new IJavaElement[]{wc});
		ISearchPattern pattern= createSearchPattern(wc.findPrimaryType());
		SearchResultGroup[] groups= RefactoringSearchEngine.search(pm, scope, pattern, new ICompilationUnit[]{wc});
		Assert.isTrue(groups.length <= 1); //just 1 file or none
		if (groups.length == 0)
			return null;
		else	
			return groups[0];
	}
	
	private static 	ISearchPattern createSearchPattern(IType type) throws JavaModelException{
		ISearchPattern pattern= SearchEngine.createSearchPattern(type, IJavaSearchConstants.ALL_OCCURRENCES);
		IMethod[] methods= type.getMethods();
		for (int i= 0; i < methods.length; i++) {
			IMethod method= methods[i];
			if (method.isConstructor()){
				ISearchPattern newPattern= SearchEngine.createSearchPattern(method, IJavaSearchConstants.DECLARATIONS);
				pattern= SearchEngine.createOrSearchPattern(pattern, newPattern);
			}	
		}
		return pattern;
	}
}