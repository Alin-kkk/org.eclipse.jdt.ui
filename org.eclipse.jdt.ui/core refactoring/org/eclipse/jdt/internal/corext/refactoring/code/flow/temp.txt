	public void endVisit(ArrayQualifiedTypeReference node, BlockScope scope) {
		// Leaf node.
	}

	public void endVisit(ArrayQualifiedTypeReference node, ClassScope scope) {
		// Leaf node.
	}

	public void endVisit(ArrayTypeReference node, BlockScope scope) {
		// Leaf node.
	}

	public void endVisit(ArrayTypeReference node, ClassScope scope) {
		// Leaf node.
	}

	public void endVisit(BinaryExpression node, BlockScope scope) {
		if (skipNode(node))
			return;
		processSequential(node, node.left, node.right);
	}

	public void endVisit(Case node, BlockScope scope) {
		if (skipNode(node))
			return;
		assignFlowInfo(node, node.constantExpression);
	}

	public void endVisit(ClassLiteralAccess node, BlockScope scope) {
		if (skipNode(node))
			return;
		assignFlowInfo(node, node.type);
	}

	public void endVisit(Clinit node, ClassScope scope) {
		// Leaf node.
	}

	public void endVisit(CompoundAssignment node, BlockScope scope) {
		if (skipNode(node))
			return;
		endVisit((Assignment)node, scope);
	}

	public void endVisit(ConstructorDeclaration node, ClassScope scope) {
		if (skipRange(node.declarationSourceStart, node.declarationSourceEnd))
			return;
		GenericSequentialFlowInfo info= processSequential(node, node.arguments);
		process(info, node.thrownExceptions);
		process(info, node.constructorCall);
		process(info, node.statements);
	}

	public void endVisit(DefaultCase node, BlockScope scope) {
		// Leaf Node
	}

	public void endVisit(DoubleLiteral node, BlockScope scope) {
		// Leaf node.
	}

	public void endVisit(EmptyStatement node, BlockScope scope) {
		// Leaf node.
	}
	
	public void endVisit(EqualExpression node, BlockScope scope) {
		if (skipNode(node))
			return;
		processSequential(node, node.left, node.right);
	}

	public void endVisit(ExplicitConstructorCall node, BlockScope scope) {
		if (skipNode(node))
			return;
		GenericSequentialFlowInfo info= processSequential(node, node.qualification);
		process(info, node.arguments);
	}

	public void endVisit(ExtendedStringLiteral node, BlockScope scope) {
		// Leaf node
	}

	public void endVisit(FalseLiteral node, BlockScope scope) {
		// Leaf node
	}

	public void endVisit(FloatLiteral floatLiteral, BlockScope scope) {
		// Leaf node.
	}

	public void endVisit(ImportReference node, CompilationUnitScope scope) {
		// Leaf node.
	}

	public void endVisit(IntLiteral intLiteral, BlockScope scope) {
		// Leaf Node.
	}

	public void endVisit(LabeledStatement node, BlockScope scope) {
		if (skipNode(node))
			return;
		FlowInfo info= assignFlowInfo(node, node.statement);
		if (info != null)
			info.removeLabel(node.label);
	}

	public void endVisit(LocalDeclaration node, BlockScope scope) {
		if (skipRange(node.declarationSourceStart, node.declarationSourceEnd))
			return;
		GenericSequentialFlowInfo info= processSequential(node, node.type, node.initialization);
		// ckeck if the local variable itself is selected. If so and we have an initialization
		// we have to track a write access.
		if (node.initialization != null && !skipRange(node.sourceStart, node.sourceEnd)) {
			info.merge(
				new LocalFlowInfo(node.binding, FlowInfo.WRITE, fFlowContext),
				fFlowContext);
		}
	}

	public void endVisit(LocalTypeDeclaration node, BlockScope scope) {
		process(node);
	}

	public void endVisit(LongLiteral node, BlockScope scope) {
		// Leaf Node.
	}

	public void endVisit(MemberTypeDeclaration node, ClassScope scope) {
		process(node);
	}

	public void endVisit(NullLiteral node, BlockScope scope) {
		// Leaf node.
	}

	public void endVisit(OR_OR_Expression node, BlockScope scope) {
		if (skipNode(node))
			return;
		processSequential(node, node.left, node.right);
	}

	public void endVisit(QualifiedAllocationExpression node, BlockScope scope) {
		if (skipNode(node))
			return;
		GenericSequentialFlowInfo info= processSequential(node, node.enclosingInstance);
		process(info, node.type);
		process(info, node.arguments);
		process(info, node.anonymousType);
	}

	public void endVisit(QualifiedNameReference node, BlockScope scope) {
		if (skipNode(node))
			return;
		if (!(node.binding instanceof LocalVariableBinding))
			return;
		setFlowInfo(node, new LocalFlowInfo(
			(LocalVariableBinding)node.binding,
			FlowInfo.READ,
			fFlowContext));
	}

	public void endVisit(QualifiedSuperReference node, BlockScope scope) {
		if (skipNode(node))
			return;
		assignFlowInfo(node, node.qualification);
	}

	public void endVisit(QualifiedThisReference node, BlockScope scope) {
		if (skipNode(node))
			return;
		assignFlowInfo(node, node.qualification);
	}

	public void endVisit(QualifiedTypeReference node, BlockScope scope) {
		// Leaf node.
	}

	public void endVisit(QualifiedTypeReference node, ClassScope scope) {
		// Leaf node.
	}

	public void endVisit(ReturnStatement node, BlockScope scope) {
		if (skipNode(node))
			return;
			
		if (createReturnFlowInfo(node)) {
			ReturnFlowInfo info= createReturn(node);
			setFlowInfo(node, info);
			info.merge(getFlowInfo(node.expression), fFlowContext);
		} else {
			assignFlowInfo(node, node.expression);
		}
	}
	
	public void endVisit(SingleNameReference node, BlockScope scope) {
		if (skipNode(node))
			return;
		if (!(node.binding instanceof LocalVariableBinding))
			return;
		setFlowInfo(node, new LocalFlowInfo(
			(LocalVariableBinding)node.binding,
			FlowInfo.READ,
			fFlowContext));
	}

	public void endVisit(SingleTypeReference node, BlockScope scope) {
		// Leaf node.
	}

	public void endVisit(SingleTypeReference node, ClassScope scope) {
		// Leaf node.
	}

	public void endVisit(StringLiteral node, BlockScope scope) {
		// Leaf node.
	}

	public void endVisit(SuperReference node, BlockScope scope) {
		// Leaf node.
	}

	public void endVisit(SwitchStatement node, BlockScope scope) {
		if (skipNode(node))
			return;
		endVisit(node, createSwitchData(node));
	}

	public void endVisit(SynchronizedStatement node, BlockScope scope) {
		if (skipNode(node))
			return;
		GenericSequentialFlowInfo info= processSequential(node, node.expression);
		process(info, node.block);
	}

	public void endVisit(ThisReference node, BlockScope scope) {
		// Leaf node.
	}

	public void endVisit(ThrowStatement node, BlockScope scope) {
		if (skipNode(node))
			return;
		ThrowFlowInfo info= createThrow();
		setFlowInfo(node, info);
		info.merge(getFlowInfo(node.exception), fFlowContext);
		info.mergeException(node.exceptionType, fFlowContext);
	}

	public void endVisit(TrueLiteral node, BlockScope scope) {
		// Leaf node.
	}

	public void endVisit(TryStatement node, BlockScope scope) {
		if (skipNode(node))
			return;
		TryFlowInfo info= createTry();
		setFlowInfo(node, info);
		info.mergeTry(getFlowInfo(node.tryBlock), fFlowContext);
		Block[] blocks= node.catchBlocks;
		if (blocks != null) {
			info.removeExceptions(node.catchArguments);
			for (int i= 0; i < blocks.length; i++) {
				info.mergeCatch(getFlowInfo(blocks[i]), fFlowContext);
			}
		}
		info.mergeFinally(getFlowInfo(node.finallyBlock), fFlowContext);
	}

	public void endVisit(TypeDeclaration node, CompilationUnitScope scope) {
		process(node);
	}

	public void endVisit(UnaryExpression node, BlockScope scope) {
		if (skipNode(node))
			return;
		assignFlowInfo(node, node.expression);
	}

	public void endVisit(WhileStatement node, BlockScope scope) {
		if (skipNode(node))
			return;
		WhileFlowInfo info= createWhile();
		setFlowInfo(node, info);
		info.mergeCondition(getFlowInfo(node.condition), fFlowContext);
		info.mergeAction(getFlowInfo(node.action), fFlowContext);
		info.removeLabel(null);
	}
	
