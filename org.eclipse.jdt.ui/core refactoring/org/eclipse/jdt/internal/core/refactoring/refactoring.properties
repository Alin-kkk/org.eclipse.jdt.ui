###################################################################
# (c) Copyright IBM Corp. 2000, 2001.
# All Rights Reserved.
###################################################################
# NLS properties for the Refactoring Core

#######################################
# org.eclipse.jdt.internal.core.refactoring

AbstractRenameChange.Renaming=Renaming...

Assert.assertion_failed=assertion failed; 
Assert.null_argument=null argument;

Checks.Choose_name=Choose a name
Checks.all_excluded=All resources have been excluded from refactoring. Cannot proceed
Checks.cannot_be_parsed=\"{0}\" has syntax errors. Content of that file will not be updated.
Checks.cu_not_created=Compilation unit could not be created for this element.
Checks.cu_not_parsed=Syntax errors in this compilation unit make this refactoring impossible to be performed correctly. Fix the errors first.
Checks.no_dot=Type name must not contain a dot (.)
Checks.no_two_dots=Compilation unit name must not contain two dots (.)
Checks.not_saved=\"{0}\" should be modified but it is not saved. Content of that file will not be updated.
Checks.cu_name_used=Cannot rename a compilation unit to \" {0}.java\" - this name is already used by another file in this directory
Checks.resource_not_accessible=Affected resource:{0} is not accesible
Checks.resource_read_only=Affected resource:{0} is read-only
Checks.method_native=Method {0}::{1} is native. Running the modified program will cause
Checks.methodName.discouraged= {0} is discouraged as a method name
Checks.methodName.exists= The new method potentially conflicts with a method in the target type. Candidate is {0}
Checks.methodInHierarchy.exists= The new method potentially conflicts with a method in the type hierarchy. Candidate is {0}
Checks.has_main=Type {0} has a main method - refactoring might cause some applications (scripts etc.) to not work

CompilationUnitChange.default_package=(default package)

CompositeChange.CompositeChange=CompositeChange>

CreateCompilationUnitChange.creating_resource=creating resource: {0}
CreateCompilationUnitChange.create_cu=Create Compilation Unit {0} in {1}

CustomSearchEngine.Searching=Searching...

DeleteCompilationUnit.deleting_resource=deleting resource: {0}
DeleteCompilationUnit.delete_cu=Delete Compilation Unit {0} from {1}

RenameResourceChange.rename_resource=rename resource
RenameResourceChange.name=Rename \"{0}\" to: {1}

TextUtilities.assert.indents=Line does not have requested number of indents

#######################################
# org.eclipse.jdt.internal.core.refactoring.base

Change.checking_for=Checking change for: {0}
Change.internal_Error=Internal Error
Change.unexpected_exception=Unexpected exception while executing a change. See log for details.

ChangeAbortException.wrapped=Exception wrapped by {0}

Refactoring.binary={0} is binary
Refactoring.not_in_model={0} does not exist in the model
Refactoring.read_only={0} is read only
Refactoring.unknown_structure={0} - unknown structure

#######################################
#org.eclipse.jdt.internal.core.refactoring.code

CommentAnalyzer.Internal_error=Internal error during precondition checking.
CommentAnalyzer.ends_inside_comment=Selection ends inside a comment.
CommentAnalyzer.starts_inside_comment=Selection starts inside a comment.

ExtractMethodRefactoring.Internal_error=Internal error: compilation unit has wrong type.
ExtractMethodRefactoring.Syntax_errors=Syntax errors in this compilation unit prevent method extraction. Fix the errors first.
ExtractMethodRefactoring.add_method=add new method {0}
ExtractMethodRefactoring.checking_new_name=Checking new method name
ExtractMethodRefactoring.checking_selection=Checking text selection
ExtractMethodRefactoring.no_set_of_statements=Selection does not mark a set of statements. Only statements from a method body can be extracted.
ExtractMethodRefactoring.substitute_with_call=substitute statement(s) with call to {0}
ExtractMethodRefactoring.name=Extract Method {0} in {1}
ExtractMethodRefactoring.change_name=extract method {0} from method {1}

ExtractMethodAnalyzer.assignments_to_local=Ambiguous return value: selected block contains more than one assignment to local variable.

LocalTypeAnalyzer.local_type_from_outside=Selected block references a local type declared outside the selection.
LocalTypeAnalyzer.local_type_referenced_outside=A local type declared in the selected block is referenced outside the selection.

LocalVariableAnalyzer.assignment_and_reference_to_local=Ambiguous return value: assignment to local variable and reference to a selected local declaration found.
LocalVariableAnalyzer.assignments_to_local=Ambiguous return value: selected block contains more than one assignment to local variable.
LocalVariableAnalyzer.references_to_local=Ambiguous return value: more than one reference to selected local declaration found.
LocalVariableAnalyzer.return_statement=Ambiguous return value: selection contains return statement and a value must be returned from the extracted method.
LocalVariableAnalyzer.return_type=Ambiguous return value: expression has return type and a value must be returned from extracted method.

FlowAnalyzer.execution_flow=Selected statements contain a return statement but not all possible execution flows end in a return.

StatementAnalyzer.Cannot_determine_return_type=Cannot determine return type of the expression to be extracted.
StatementAnalyzer.a_for=a for
StatementAnalyzer.a_while=a while
StatementAnalyzer.after_do_keyword=Selection may not start right after the do keyword.
StatementAnalyzer.do_while=a do-while
StatementAnalyzer.do_while_statement=Selection must either cover whole do-while statement or parts of the action block.
StatementAnalyzer.ends_middle_of_statement=Cannot extract selection that ends in the middle of a statement.
StatementAnalyzer.if-then-else=an if-then-else
StatementAnalyzer.if_then_else_statement=Selection must either cover whole if-then-else statement or parts of then, or else block.
StatementAnalyzer.middle_of_type_declaration=Selection starts or ends in the middle of a type declaration. Select whole declaration or statements of a method body.
StatementAnalyzer.no_break_target=Cannot find break target.
StatementAnalyzer.only_method_body=Cannot extract new method from selection. Only statements from a method body can be extracted.
StatementAnalyzer.return_statement=Cannot extract to new method since selection contains a return statement at line {0}.
StatementAnalyzer.single_return=Cannot extract a single return statement.
StatementAnalyzer.switch_statement=Selection must either cover whole switch statement or parts of a single case block.
StatementAnalyzer.synchronized_statement=Seleciton must either cover whole synchronized statement or parts of the synchronized block.
StatementAnalyzer.try_statement=Selection must either cover whole try statement or parts of try, catch, or finally block.
StatementAnalyzer.void_return=Can only extract void return statement.
StatementAnalyzer.not_all_selected=Selection contains a {0} target but not all corresponding {1} statements are selected.
StatementAnalyzer.targer_not_selected=Selection contains a {0} statement but the corresponding {1} target is not selected.
StatementAnalyzer.cannot_from_condition_part=Cannot extract the selected statement(s) from the condition part of {0} statement.
StatementAnalyzer.compilation_error=Compilation error at line {0} prevents method extraction: {1}
StatementAnalyzer.expression_and_return_value=Ambigious return value: return statement is to be extracted and new method must return a value due to an assignment to a local variable.
StatementAnalyzer.for_statement=Selection must either cover whole for statement or parts of the action block, or the condition expression.
StatementAnalyzer.super_or_this=Cannot extract super or this call from constructor.

SelfEncapsulateField.method_exists=A method with the name ''{0}'' already exists.
SelfEncapsulateField.compilation_error=Compilation error at line {0} prevents refactoring: {1}
SelfEncapsulateField.syntax_errors=Syntax errors in {0} prevent refactoring. Fix the errors first.
SelfEncapsulateField.getter=get{0}
SelfEncapsulateField.setter=set{0}
SelfEncapsulateField.syntax_errors_update={0} contains syntax error. Field accesses will not be updated.
SelfEncapsulateField.compiler_errors_update={0} contains compiler errors. This may affect field access update.

#######################################
#org.eclipse.jdt.internal.core.refactoring.cus

MoveCompilationUnitChange.default_package=(default package)
MoveCompilationUnitChange.moving=moving the compilation unit
MoveCompilationUnitChange.name=Move Compilation Unit {0} to: {1}

MoveCompilationUnitRefactoring.assert.refs_in_many_files=should not find references in more than 1 file
MoveCompilationUnitRefactoring.add_import=add import declaration {0}
MoveCompilationUnitRefactoring.analyzing=Analyzing references...
MoveCompilationUnitRefactoring.checking=Checking preconditions...
MoveCompilationUnitRefactoring.choose_another=Please choose another package
MoveCompilationUnitRefactoring.computing_imports=computing imports
MoveCompilationUnitRefactoring.creating_change=creating change
MoveCompilationUnitRefactoring.out_default=Moving out of the the default package is not supported
MoveCompilationUnitRefactoring.package_visible=package-visible
MoveCompilationUnitRefactoring.protected=protected
MoveCompilationUnitRefactoring.searching=Searching for references...
MoveCompilationUnitRefactoring.to_default=Moving to the default package is not supported
MoveCompilationUnitRefactoring.update_import=update import declaration
MoveCompilationUnitRefactoring.update_reference=update type reference
MoveCompilationUnitRefactoring.name=Move \"{0}\" to: {1}
MoveCompilationUnitRefactoring.already_exists=Compilation unit \"{0}\" already exists in {1}
MoveCompilationUnitRefactoring.type_conflict=Possible name conflict between types {0} and {1} in \"{2}\"
MoveCompilationUnitRefactoring.ref_to_ouside_element=A {0} Java element declared outside of \"{1}\" is referenced in there. 
MoveCompilationUnitRefactoring.element_referenced_ouside=A {0} java element declared in \"{1}\" is referenced in \"{2}\" (refactoring may result in compile errors)
MoveCompilationUnitRefactoring.type_exists=Type {0} exists in {1} (compilation unit: \"{2}\")
MoveCompilationUnitRefactoring.type_conflict_1=Possible name conflict between type {0} (from {1}) and {2} declared in: {3}

RenameCompilationUnitChange.name=Rename compilation unit: {0} to: {1}
RenameCompilationUnitChange.assert.read_only=cu must not be read-only

RenameCompilationUnitRefactoring.name=Rename \"{0}\" to \"{1}\"
RenameCompilationUnitRefactoring.not_in_model={0} does not exist in the model
RenameCompilationUnitRefactoring.not_parsed={0} has syntax errors. No references will be updated if you proceed
RenameCompilationUnitRefactoring.not_parsed_1={0} has syntax errors.
RenameCompilationUnitRefactoring.read_only={0} is read only
RenameCompilationUnitRefactoring.same_name=The same name chosen

#######################################
#org.eclipse.jdt.internal.core.refactoring.fields

FieldRefactoring.assert.field_must_exist=field must exist

RenameFieldASTAnalyzer.error=Possible problems in \"{0}\" (line number: {1}). Name {2} is already used.

RenameFieldRefactoring.name=Rename field {0} to: {1}
RenameFieldRefactoring.hiding=After renaming, the field {0} will be hidden in the scope of the field {1} declared in type {2}
RenameFieldRefactoring.hiding2=After renaming, the field named {0} declared in type {1} will be hidden in the scope of the field {2}
RenameFieldRefactoring.analyzing=Analyzing \"{0}\"...
RenameFieldRefactoring.another_name=Choose another name.
RenameFieldRefactoring.checking=Checking preconditions...
RenameFieldRefactoring.creating_change=Updating...
RenameFieldRefactoring.field_already_defined=Field with this name is already defined.
RenameFieldRefactoring.searching=Searching for references...
RenameFieldRefactoring.update_reference=update field reference
RenameFieldRefactoring.update_references_to=update references to {0}

#######################################
#org.eclipse.jdt.internal.core.refactoring.methods

MethodRefactoring.assert.must_exist=method must exist

RenameMethodASTAnalyzer.name_visible=Possible problems in \"{0}\" (line number:{1}). Name {2} is already visible.

RenameMethodInInterfaceRefactoring.already_defined=A related type declares a method with the new name (and same number of parameters)
RenameMethodInInterfaceRefactoring.analyzing_hierarchy=Analyzing hierarchy...
RenameMethodInInterfaceRefactoring.checking=Checking preconditions...
RenameMethodInInterfaceRefactoring.no_class_method=Not applicable to class methods
RenameMethodInInterfaceRefactoring.special_case=Cannot rename this method because it is a special case (see the language specification section 9.2 for details)

RenameMethodRefactoring.name=Rename method {0} to: {1} 
RenameMethodRefactoring.analyzing_hierarchy=Analyzing hierarchy...
RenameMethodRefactoring.checking_name=checking new name
RenameMethodRefactoring.creating_change=Updating...
RenameMethodRefactoring.creating_pattern=Creating the searching pattern...
RenameMethodRefactoring.no_binary=Related method {0} (declared in {1}) is binary. Refactoring cannot be performed.
RenameMethodRefactoring.no_constructors=Not applicable to contructors
RenameMethodRefactoring.no_native=Renaming native methods will cause an unsatisfied link error on runtime.
RenameMethodRefactoring.no_native_1=Related method {0} (declared in {1}) is native. Renaming will cause an unsatisfied link error on runtime.
RenameMethodRefactoring.no_read_only=Related method {0} (declared in {1}) is read-only. Refactoring cannot be performed.
RenameMethodRefactoring.not_in_model=Related method {0} (declared in {1}) does not exist in the model.
RenameMethodRefactoring.same_name=Same name chosen
RenameMethodRefactoring.searching=Searching for references...
RenameMethodRefactoring.special_case=This method is a special case - renaming might change program''s behavior.
RenameMethodRefactoring.update_reference=update method reference
RenameMethodRefactoring.update_references=update method references

RenameParameterASTAnalyzer.error=Problem in line:{0}. Name {1} is already visible.
RenameParameterASTAnalyzer.error2=Problem in line:{0} Local variable named {1} already exists.

RenameParametersRefactoring.checking=Checking preconditions...
RenameParametersRefactoring.creating_change=Updating...
RenameParametersRefactoring.duplicate_name=Duplicate parameter name: {0}
RenameParametersRefactoring.no_change=All parameter names are unchanged. Please enter new parameter names
RenameParametersRefactoring.no_parameters=Only applicable to methods with parameters.
RenameParametersRefactoring.not_saved=Compilation unit must be saved before performing this refactoring.
RenameParametersRefactoring.number_of_parameters=Must have the same number of parameters
RenameParametersRefactoring.rename_method_parameters=rename method parameters
RenameParametersRefactoring.rename_parameters=Rename Method Parameters
RenameParametersRefactoring.update_reference=update parameter reference
RenameParametersRefactoring.assert.name_null=parameter name is null: 
RenameParametersRefactoring.assert.names_null=names must not be null
RenameParametersRefactoring.assert.one_parameter=must have at least 1 parameter
RenameParametersRefactoring.assert.same_number=must have the same number of parameters

RenamePrivateMethodRefactoring.analyzing_cu=Analyzing compilation unit...
RenamePrivateMethodRefactoring.analyzing_hierarchy=Analyzing hierarchy...
RenamePrivateMethodRefactoring.checking=Checking preconditions...
RenamePrivateMethodRefactoring.declaration_change=Method declaration change
RenamePrivateMethodRefactoring.only_private=Only applicable to private methods
RenamePrivateMethodRefactoring.rename_method=Rename Method
RenamePrivateMethodRefactoring.assert.nothing_found=no declarations/references to a method found
RenamePrivateMethodRefactoring.assert.references_outside_cu=references to a private method found outside of its compilation unit
RenamePrivateMethodRefactoring.hierarchy_defines={0} or a type in its hierarchy defines a method named {1}

RenameStaticMethodRefactoring.analyzing_hierachy=Analyzing hierachy...
RenameStaticMethodRefactoring.checking=Checking preconditions...
RenameStaticMethodRefactoring.no_private=must not be private
RenameStaticMethodRefactoring.only_static=must be static
RenameStaticMethodRefactoring.hierachy_declares=Hierarchy declares a method named {0} with the same number of parameters.

RenameVirtualMethodRefactoring.analyzing_hierarchy=Analyzing hierarchy...
RenameVirtualMethodRefactoring.checking=Checking preconditions...
RenameVirtualMethodRefactoring.no_private=not applicable to private methods
RenameVirtualMethodRefactoring.no_static=not applicable to static methods
RenameVirtualMethodRefactoring.only_class_methods=only applicable to class methods
RenameVirtualMethodRefactoring.overrides_another=This method overrides another one - rename it in the most abstract type that declares it.
RenameVirtualMethodRefactoring.from_interface=Method {0} is declared in an interface - rename it there.
RenameVirtualMethodRefactoring.requieres_renaming_native=Renaming {0} requires renaming a native method. Renaming will cause {1} on runtime.
RenameVirtualMethodRefactoring.hierarchy_declares1=Hierarchy declares a method {0} with the same number of parameters.
RenameVirtualMethodRefactoring.analyzing=Analyzing \"{0}\"...

#######################################
#org.eclipse.jdt.internal.core.refactoring.packages

RenamePackageASTAnalyzer.error=Possible obscuring problems in \"{0}\" (line number: {1}). Name {2} is already used.

RenamePackageChange.checking_change=Checking change for: {0}
RenamePackageChange.name=Rename package:{0} to:{1}
RenamePackageChange.assert.read_only=package must not be read-only

RenamePackageRefactoring.analyzing=Analyzing...
RenamePackageRefactoring.another_name=Choose another name.
RenamePackageRefactoring.checking=Checking preconditions...
RenamePackageRefactoring.creating_change=Updating...
RenamePackageRefactoring.no_default_package=Cannot rename the default package
RenamePackageRefactoring.package_exists=Package already exists
RenamePackageRefactoring.searching=Searching for references...
RenamePackageRefactoring.update_reference=update package reference
RenamePackageRefactoring.update_references_to=update references to {0}
RenamePackageRefactoring.assert.must_exist=package must exist
RenamePackageRefactoring.name=Rename package: {0} to: {1}
RenamePackageRefactoring.aleady_exists=Package {0} already exists in this project
RenamePackageRefactoring.analyzing_formatted=Analyzing \"{0}\"...


#######################################
#org.eclipse.jdt.internal.core.refactoring.text

AbstractTextBufferChange.undo=Undo {0}
SimpleTextChange.assert.offset_negative=Offset must not be negative.
SimpleTextChange.assert.only_from={0} can only be executed from within a {1}

#######################################
#org.eclipse.jdt.internal.core.refactoring.types

RenameTypeASTAnalyzer.import_conflict={0} causes a name conflict in import declarations in \"{1}\"
RenameTypeASTAnalyzer.conflict_with_declared_type={0} imports {1} and declares a top-level type named {2}
RenameTypeASTAnalyzer.native_param={0} is used as a parameter type for a native method {1} in \"{2}\" (line number:{3})
RenameTypeASTAnalyzer.refers_and_imports={0} refers to a type named {1} (line number:{2}) and imports (single-type-import) {3}
RenameTypeASTAnalyzer.name_visible=Name {0} is already visible in \"{1}\" (line number: {2})
RenameTypeASTAnalyzer.subclass={0} has a subclass named {1}
RenameTypeASTAnalyzer.superinterface_conflict=Name {0} is in conflict with superinterfaces list for type {1}

RenameTypeRefactoring.checking=Checking preconditions...
RenameTypeRefactoring.choose_another_name=Please choose another name.
RenameTypeRefactoring.creating_change=Updating...
RenameTypeRefactoring.only_toplevel=Only applicable to top level types
RenameTypeRefactoring.rename_constructor=rename constructor
RenameTypeRefactoring.searching=Searching for references...
RenameTypeRefactoring.special_case=It is a special case
RenameTypeRefactoring.update_reference=update type reference
RenameTypeRefactoring.update_references_to=update references to {0}
RenameTypeRefactoring.name=Rename type:{0} to:{1}
RenameTypeRefactoring.enclosed=Type {0} is enclosed in a type named {1}
RenameTypeRefactoring.encloses=Type {0} encloses a type named {1}
RenameTypeRefactoring.exists=Type named {0} already exists in package {1}
RenameTypeRefactoring.imported=Type named {0} is imported (single-type-import) in {1} (a compilation unit must not import and declare a type with the same name)
RenameTypeRefactoring.type_exists_in_cu=Type {0} already exists in \"{1}\"
RenameTypeRefactoring.member_type_exists=Another member type named {0} already exists in {1}
RenameTypeRefactoring.local_type_name=A local type enclosed in type {0} is already named {1}
RenameTypeRefactoring.enclosed_type_name=A type enclosed in type {0} is already named {1}
RenameTypeRefactoring.local_type_native=A local type enclosed in type {0} declares a native method. Renaming will cause an unsatisfied link error on runtime.
RenameTypeRefactoring.enclosed_type_native=A type enclosed in type {0} declares a native method. Renaming will cause an unsatisfied link error on runtime.
RenameTypeRefactoring.name_conflict1=Name conflict with type {0} in {1}
RenameTypeRefactoring.analyzing=Analyzing \"{0}\"...
RenameTypeRefactoring.name_conflict2=Name conflict with type {0} declared in \"{1}\"

TypeRefactoring.assert.must_exist=type must exist
TypeRefactoring.assert.must_exist_1=package must exist
TypeRefactoring.assert.read-only=package must not be read-only
Checks.should_start_lowercase=By convention, Java package names usually start with a lowercase letter.
RenameFieldRefactoring.should_start_lowercase=By convention, Java instance field names usually start with a lowercase letter.
RenameParametersRefactoring.should_start_lowercase=By convention, method parameter names usually start with a lowercase letter.
