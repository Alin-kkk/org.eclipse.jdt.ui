/* * (c) Copyright IBM Corp. 2000, 2001. * All Rights Reserved. */package org.eclipse.jdt.internal.core.refactoring.base;import org.eclipse.core.resources.IFile;import org.eclipse.core.resources.IResource;import org.eclipse.core.runtime.IProgressMonitor;import org.eclipse.core.runtime.IStatus;import org.eclipse.core.runtime.Status;import org.eclipse.jdt.core.ICompilationUnit;import org.eclipse.jdt.core.IJavaElement;import org.eclipse.jdt.core.JavaCore;import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jdt.internal.core.refactoring.RefactoringCoreMessages;/** * An abstract default implementation for a change object - suitable for subclassing. This class manages * the change's active status. * <p> * <bf>NOTE:<bf> This class/interface is part of an interim API that is still under development  * and expected to change significantly before reaching stability. It is being made available at  * this early stage to solicit feedback from pioneering adopters on the understanding that any  * code that uses this API will almost certainly be broken (repeatedly) as the API evolves.</p> */public abstract class Change implements IChange {	private boolean fIsActive= true;	/* (Non-Javadoc)	 * Method declared in IChange.	 */	public RefactoringStatus aboutToPerform(ChangeContext context, IProgressMonitor pm) {		pm.beginTask("", 1); //$NON-NLS-1$		// PR: 1GEWDUH: ITPJCORE:WINNT - Refactoring - Unable to undo refactor change		RefactoringStatus result= new RefactoringStatus();		IJavaElement element= getCorrespondingJavaElement();		if (element != null && context.getUnsavedFiles().length > 0) {			pm.subTask(RefactoringCoreMessages.getFormattedString("Change.checking_for", element.getElementName())); //$NON-NLS-1$			checkIfResourceIsUnsaved(element, result, context);		}		pm.worked(1);		return result;	}			/* (Non-Javadoc)	 * Method declared in IChange.	 */	public void performed() {		// do nothing.	} 		/* (Non-Javadoc)	 * Method declared in IChange.	 */	public void setActive(boolean active) {		fIsActive= active;	}		/* (Non-Javadoc)	 * Method declared in IChange.	 */	public boolean isActive() {		return fIsActive;	}		/* (Non-Javadoc)	 * Method declared in IChange.	 */	public boolean isUndoable() {		return true;	}		/* (Non-Javadoc)	 * debugging only	 */		public String toString(){		return getName();	}		/**	 * Handles the given exception using the <code>IChangeExceptionHandler</code> provided by	 * the given change context. If the execution of the change is to be aborted than	 * this method throws a corresponding <code>JavaModelException</code>. The exception	 * is either the given exception if it is an instance of <code>JavaModelException</code> or	 * a new one created by calling <code>new JavaModelException(exception, code)</code>.	 * 	 * @param context the change context used to retrieve the exception handler	 * @param exception the exception caugth during change execution	 * @exception <code>ChangeAbortException</code> if the execution is to be aborted	 */	protected void handleException(ChangeContext context, Exception exception) throws ChangeAbortException {		if (exception instanceof ChangeAbortException)			throw (ChangeAbortException)exception;					context.getExceptionHandler().handle(context, this, exception);	}		protected static void checkIfResourceIsUnsaved(IResource resource, RefactoringStatus status, ChangeContext context) {		// PR: 1GEWDUH: ITPJCORE:WINNT - Refactoring - Unable to undo refactor change		if (resource instanceof IFile) {			context.checkUnsavedFile(status, (IFile)resource);		}	}		protected static void checkIfResourceIsUnsaved(IJavaElement element, RefactoringStatus status, ChangeContext context) {		// PR: 1GEWDUH: ITPJCORE:WINNT - Refactoring - Unable to undo refactor change		while (element != null && !(element instanceof ICompilationUnit))			element= element.getParent();				// We can find a handle referenced by one of your changes.			if (element == null || !element.exists())			return;					ICompilationUnit unit= (ICompilationUnit)element;		if (unit.isWorkingCopy())			element= unit.getOriginalElement();						try {			checkIfResourceIsUnsaved(element.getUnderlyingResource(), status, context);		} catch (JavaModelException e) {			handleJavaModelException(e, status);		}	}	protected static void handleJavaModelException(JavaModelException e, RefactoringStatus status) {		if (e.isDoesNotExist()) {			// If the Java Element doesn't exist then it can't be unsaved.			return;		}		status.addFatalError(RefactoringCoreMessages.getString("Change.unexpected_exception")); //$NON-NLS-1$		JavaCore.getJavaCore().getLog().log(			new Status(				IStatus.ERROR, 				JavaCore.getJavaCore().getDescriptor().getUniqueIdentifier(), 				IStatus.ERROR, 				RefactoringCoreMessages.getString("Change.internal_Error"), e));		 //$NON-NLS-1$	}	}