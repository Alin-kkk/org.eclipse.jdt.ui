/* * (c) Copyright IBM Corp. 2000, 2001. * All Rights Reserved. */package org.eclipse.jdt.internal.core.refactoring.base;import org.eclipse.core.resources.IFile;import org.eclipse.core.resources.IResource;import org.eclipse.core.runtime.IProgressMonitor;import org.eclipse.core.runtime.IStatus;import org.eclipse.core.runtime.Status;import org.eclipse.jdt.core.ICompilationUnit;import org.eclipse.jdt.core.IJavaElement;import org.eclipse.jdt.core.JavaCore;import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jdt.internal.core.refactoring.RefactoringCoreMessages;/** * An abstract default implementation for a change object - suitable for subclassing. This class manages * the change's active status. * <p> * <bf>NOTE:<bf> This class/interface is part of an interim API that is still under development  * and expected to change significantly before reaching stability. It is being made available at  * this early stage to solicit feedback from pioneering adopters on the understanding that any  * code that uses this API will almost certainly be broken (repeatedly) as the API evolves.</p> */public abstract class Change implements IChange {	private boolean fIsActive= true;	/* (Non-Javadoc)	 * Method declared in IChange.	 */	public RefactoringStatus aboutToPerform(ChangeContext context, IProgressMonitor pm) {		pm.beginTask("", 1); //$NON-NLS-1$		// PR: 1GEWDUH: ITPJCORE:WINNT - Refactoring - Unable to undo refactor change		RefactoringStatus result= new RefactoringStatus();		IFile file= getFile(getModifiedLanguageElement());		if (file != null && context.getUnsavedFiles().length > 0) {			pm.subTask(RefactoringCoreMessages.getFormattedString("Change.checking_for", file.getName())); //$NON-NLS-1$			context.checkUnsavedFile(result, file);		}		pm.worked(1);		return result;	}		/* (Non-Javadoc)	 * Method declared in IChange.	 */	public void performed() {		// do nothing.	} 		/* (Non-Javadoc)	 * Method declared in IChange.	 */	public void setActive(boolean active) {		fIsActive= active;	}		/* (Non-Javadoc)	 * Method declared in IChange.	 */	public boolean isActive() {		return fIsActive;	}	/* (Non-Javadoc)	 * Method declared in IChange.	 */	public boolean isUndoable() {		return true;	}		/* (Non-Javadoc)	 * debugging only	 */		public String toString(){		return getName();	}		/**	 * Handles the given exception using the <code>IChangeExceptionHandler</code> provided by	 * the given change context. If the execution of the change is to be aborted than	 * this method throws a corresponding <code>JavaModelException</code>. The exception	 * is either the given exception if it is an instance of <code>JavaModelException</code> or	 * a new one created by calling <code>new JavaModelException(exception, code)</code>.	 * 	 * @param context the change context used to retrieve the exception handler	 * @param exception the exception caugth during change execution	 * @exception <code>ChangeAbortException</code> if the execution is to be aborted	 */	protected void handleException(ChangeContext context, Exception exception) throws ChangeAbortException {		if (exception instanceof ChangeAbortException)			throw (ChangeAbortException)exception;					context.getExceptionHandler().handle(context, this, exception);	}		protected static void checkIfResourceIsUnsaved(IJavaElement element, RefactoringStatus status, ChangeContext context) {		IFile file= getFile(element);		if (file != null)			context.checkUnsavedFile(status, file);	}	protected static void handleJavaModelException(JavaModelException e, RefactoringStatus status) {		if (e.isDoesNotExist()) {			// If the Java Element doesn't exist then it can't be unsaved.			return;		}		status.addFatalError(RefactoringCoreMessages.getString("Change.unexpected_exception")); //$NON-NLS-1$		JavaCore.getJavaCore().getLog().log(			new Status(				IStatus.ERROR, 				JavaCore.getJavaCore().getDescriptor().getUniqueIdentifier(), 				IStatus.ERROR, 				RefactoringCoreMessages.getString("Change.internal_Error"), e));		 //$NON-NLS-1$	}		private static IFile getFile(Object element) {		try {			if (element instanceof IFile) {				return (IFile)element;			} else if (element instanceof IJavaElement) {				IJavaElement javaElement= (IJavaElement)element;				while (javaElement != null && !(javaElement instanceof ICompilationUnit))					javaElement= javaElement.getParent();				ICompilationUnit unit= (ICompilationUnit)javaElement;				if (unit != null && unit.exists()) {					if (unit.isWorkingCopy())						unit= (ICompilationUnit)unit.getOriginalElement();					return (IFile)unit.getUnderlyingResource();				}			}		} catch (JavaModelException e) {			// fall through		}		return null;	}	}